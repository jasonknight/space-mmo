In the models.py, in each model, `def set_id` should be 'private' and only be used internally, like when calling `from_thrift`. The reason for this is that users shouldn't be managing ids for models. That's really an internal type thing. `def get_id` is fine, because users should be able to read an id. Don't actually change the models.py file, we need to change this in the `generate_models.py` generation script.

In `Attribute.from_thrift` the code that unwraps and sets up the `value` field is reversed. We should test vector3 first, then asset_id, then double_value, and finally `bool_value` is the default kind of value. Because we use `if, elif` style logic, there is no final else clause, which will leave all values with null. Even though that is fine, because the default when we read the value back is to fallback to `bool_value` still, the code here should express the actual idea. In this case, the handling for `bool_value` should be in the `else:` clause, we should test if the value  `is not None`, and set it, otherwise, default to `self.data['bool_value'] = False`. 

The same problem as above is also in the `Attribute.into_thrift` function. When we unwrap the `AttributeValue` we start with `if self._data.get('bool_value') is not None`. This should be in the `else` clause, as it is the `default and fallback` in case we can't figure out what the `AttributeValue` is. We should start with the most complex, i.e. `ItemVector3`. Because we are using only `if, elif` there is no default case, which there should be. The default case is `bool_value`.

In the `def save` functions there is a possible issue. The first test is `if not self._dirty` and it returns if the current item is not dirty. But Python passes objects by reference, so even though this object is not dirty, that doesn't guarantee that non of the relation objects isn't dirty. Let's look at an example with Inventory. Because the logic to save all InventoryItems comes after this `if not self._dirty` we will have failed to save any of the `InventoryEntry` or `InventoryOwner` relationships if those had changed. If you make a change to a child object, does it update the parent's `_dirty` value? I assume not. The `_dirty` setting should prevent us from actually sending `SQL` statements, but should not prevent us from traversing the relationships and calling save on each of those. 

Because we are using caching, we should also add a method `reload` to every model that regardless of anything else, reloads everything, and even iterates over its relations (by way of the cache so we only hit models already loaded) and calls reload on those as well. 

#Please stop making trivial comments in getters and setters, for instance `def set_quantity` has a comment in the body of the function `"""Set the value of quantity"""`. Is that really necessary? `set_quantity` and `Set the value of quantity` are semantically the same information.

For functions that could return an Optional value, like `None`, we need to make the return type `Optional[...]` and example would be `def get_item(self, strict: bool = False) -> 'Item'` should be `def get_item(self, strict: bool = False) -> Optional['Item']` to express to the user that checking for `None` is required.

All `set_*` setter functions that return `None` should actually return `self` to create a fluid interface, and allow for method chaining during model setup.

Some fields, like `attribute_type` need to be stored in the DB as strings of the AttributeType enum. But when we allow a user to `set_attribute_type` we should constrain those values to only those allowed from the current implementation of the AttributeType thrift Enum. The same is true for `item_type`. The thrift generated code has data on the class that would allow you to verify the values being set. Also, the argument should not accept a string, but should require the actual thrift enum as a value, and raise an error if they try to use a string. Strings can be mispelled etc, and we want to allow for type checking.