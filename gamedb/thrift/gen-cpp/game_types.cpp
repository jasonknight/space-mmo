/**
 * Autogenerated by Thrift Compiler (0.23.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "game_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kItemTypeValues[] = {
  ItemType::VIRTUAL,
  ItemType::CONTAINER,
  ItemType::WEAPON,
  ItemType::RAWMATERIAL,
  ItemType::REFINEDMATERIAL
};
const char* _kItemTypeNames[] = {
  "VIRTUAL",
  "CONTAINER",
  "WEAPON",
  "RAWMATERIAL",
  "REFINEDMATERIAL"
};
const std::map<int, const char*> _ItemType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kItemTypeValues, _kItemTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ItemType::type& val) {
  std::map<int, const char*>::const_iterator it = _ItemType_VALUES_TO_NAMES.find(val);
  if (it != _ItemType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ItemType::type& val) {
  std::map<int, const char*>::const_iterator it = _ItemType_VALUES_TO_NAMES.find(val);
  if (it != _ItemType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMobileTypeValues[] = {
  MobileType::PLAYER,
  MobileType::NPC
};
const char* _kMobileTypeNames[] = {
  "PLAYER",
  "NPC"
};
const std::map<int, const char*> _MobileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMobileTypeValues, _kMobileTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const MobileType::type& val) {
  std::map<int, const char*>::const_iterator it = _MobileType_VALUES_TO_NAMES.find(val);
  if (it != _MobileType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MobileType::type& val) {
  std::map<int, const char*>::const_iterator it = _MobileType_VALUES_TO_NAMES.find(val);
  if (it != _MobileType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kAttributeTypeValues[] = {
  AttributeType::TRANSLATED_NAME,
  AttributeType::TRANSLATED_SHORT_DESCRIPTION,
  AttributeType::TRANSLATED_LONG_DESCRIPTION,
  AttributeType::TRANSLATED_ASSET,
  AttributeType::UNTRANSLATED_ASSET,
  AttributeType::QUANTITY,
  AttributeType::GALACTIC_POSITION,
  AttributeType::SOLAR_POSITION,
  AttributeType::GLOBAL_POSITION,
  AttributeType::LOCAL_POSITION,
  AttributeType::SIZE,
  AttributeType::ITEM,
  AttributeType::PURITY,
  AttributeType::VOLUME
};
const char* _kAttributeTypeNames[] = {
  "TRANSLATED_NAME",
  "TRANSLATED_SHORT_DESCRIPTION",
  "TRANSLATED_LONG_DESCRIPTION",
  "TRANSLATED_ASSET",
  "UNTRANSLATED_ASSET",
  "QUANTITY",
  "GALACTIC_POSITION",
  "SOLAR_POSITION",
  "GLOBAL_POSITION",
  "LOCAL_POSITION",
  "SIZE",
  "ITEM",
  "PURITY",
  "VOLUME"
};
const std::map<int, const char*> _AttributeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kAttributeTypeValues, _kAttributeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const AttributeType::type& val) {
  std::map<int, const char*>::const_iterator it = _AttributeType_VALUES_TO_NAMES.find(val);
  if (it != _AttributeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const AttributeType::type& val) {
  std::map<int, const char*>::const_iterator it = _AttributeType_VALUES_TO_NAMES.find(val);
  if (it != _AttributeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kStatusTypeValues[] = {
  StatusType::SUCCESS,
  StatusType::FAILURE,
  StatusType::SKIP
};
const char* _kStatusTypeNames[] = {
  "SUCCESS",
  "FAILURE",
  "SKIP"
};
const std::map<int, const char*> _StatusType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kStatusTypeValues, _kStatusTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const StatusType::type& val) {
  std::map<int, const char*>::const_iterator it = _StatusType_VALUES_TO_NAMES.find(val);
  if (it != _StatusType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const StatusType::type& val) {
  std::map<int, const char*>::const_iterator it = _StatusType_VALUES_TO_NAMES.find(val);
  if (it != _StatusType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGameErrorValues[] = {
  GameError::INV_MAX_ITEMS_REACHED,
  GameError::INV_ALL_ENTRIES_MAX_STACKED,
  GameError::INV_NEW_VOLUME_TOO_HIGH,
  GameError::INV_CANNOT_ADD_ITEM,
  GameError::INV_FAILED_TO_ADD,
  GameError::INV_FAILED_TO_TRANSFER,
  GameError::INV_COULD_NOT_FIND_ENTRY,
  GameError::INV_NEW_QUANTITY_INVALID,
  GameError::INV_FULL_CANNOT_SPLIT,
  GameError::INV_ITEM_NOT_FOUND,
  GameError::INV_INSUFFICIENT_QUANTITY,
  GameError::INV_OPERATION_FAILED,
  GameError::DB_CONNECTION_FAILED,
  GameError::DB_TRANSACTION_FAILED,
  GameError::DB_INSERT_FAILED,
  GameError::DB_UPDATE_FAILED,
  GameError::DB_DELETE_FAILED,
  GameError::DB_QUERY_FAILED,
  GameError::DB_RECORD_NOT_FOUND,
  GameError::DB_INVALID_DATA,
  GameError::DB_FOREIGN_KEY_VIOLATION,
  GameError::DB_UNIQUE_CONSTRAINT_VIOLATION
};
const char* _kGameErrorNames[] = {
  "INV_MAX_ITEMS_REACHED",
  "INV_ALL_ENTRIES_MAX_STACKED",
  "INV_NEW_VOLUME_TOO_HIGH",
  "INV_CANNOT_ADD_ITEM",
  "INV_FAILED_TO_ADD",
  "INV_FAILED_TO_TRANSFER",
  "INV_COULD_NOT_FIND_ENTRY",
  "INV_NEW_QUANTITY_INVALID",
  "INV_FULL_CANNOT_SPLIT",
  "INV_ITEM_NOT_FOUND",
  "INV_INSUFFICIENT_QUANTITY",
  "INV_OPERATION_FAILED",
  "DB_CONNECTION_FAILED",
  "DB_TRANSACTION_FAILED",
  "DB_INSERT_FAILED",
  "DB_UPDATE_FAILED",
  "DB_DELETE_FAILED",
  "DB_QUERY_FAILED",
  "DB_RECORD_NOT_FOUND",
  "DB_INVALID_DATA",
  "DB_FOREIGN_KEY_VIOLATION",
  "DB_UNIQUE_CONSTRAINT_VIOLATION"
};
const std::map<int, const char*> _GameError_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(22, _kGameErrorValues, _kGameErrorNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GameError::type& val) {
  std::map<int, const char*>::const_iterator it = _GameError_VALUES_TO_NAMES.find(val);
  if (it != _GameError_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GameError::type& val) {
  std::map<int, const char*>::const_iterator it = _GameError_VALUES_TO_NAMES.find(val);
  if (it != _GameError_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Owner::~Owner() noexcept {
}

Owner::Owner() noexcept
   : mobile_id(0),
     item_id(0),
     asset_id(0) {
}

void Owner::__set_mobile_id(const MobileId val) {
  this->mobile_id = val;
__isset.mobile_id = true;
}

void Owner::__set_item_id(const ItemId val) {
  this->item_id = val;
__isset.item_id = true;
}

void Owner::__set_asset_id(const AssetId val) {
  this->asset_id = val;
__isset.asset_id = true;
}
std::ostream& operator<<(std::ostream& out, const Owner& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Owner::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mobile_id);
          this->__isset.mobile_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->item_id);
          this->__isset.item_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->asset_id);
          this->__isset.asset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Owner::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Owner");

  if (this->__isset.mobile_id) {
    xfer += oprot->writeFieldBegin("mobile_id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->mobile_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.item_id) {
    xfer += oprot->writeFieldBegin("item_id", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->item_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.asset_id) {
    xfer += oprot->writeFieldBegin("asset_id", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->asset_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Owner &a, Owner &b) noexcept {
  using ::std::swap;
  swap(a.mobile_id, b.mobile_id);
  swap(a.item_id, b.item_id);
  swap(a.asset_id, b.asset_id);
  swap(a.__isset, b.__isset);
}

bool Owner::operator==(const Owner & rhs) const
{
  if (__isset.mobile_id != rhs.__isset.mobile_id)
    return false;
  else if (__isset.mobile_id && !(mobile_id == rhs.mobile_id))
    return false;
  if (__isset.item_id != rhs.__isset.item_id)
    return false;
  else if (__isset.item_id && !(item_id == rhs.item_id))
    return false;
  if (__isset.asset_id != rhs.__isset.asset_id)
    return false;
  else if (__isset.asset_id && !(asset_id == rhs.asset_id))
    return false;
  return true;
}

Owner::Owner(const Owner& other0) noexcept {
  mobile_id = other0.mobile_id;
  item_id = other0.item_id;
  asset_id = other0.asset_id;
  __isset = other0.__isset;
}
Owner& Owner::operator=(const Owner& other1) noexcept {
  mobile_id = other1.mobile_id;
  item_id = other1.item_id;
  asset_id = other1.asset_id;
  __isset = other1.__isset;
  return *this;
}
void Owner::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Owner(";
  out << "mobile_id="; (__isset.mobile_id ? (out << to_string(mobile_id)) : (out << "<null>"));
  out << ", " << "item_id="; (__isset.item_id ? (out << to_string(item_id)) : (out << "<null>"));
  out << ", " << "asset_id="; (__isset.asset_id ? (out << to_string(asset_id)) : (out << "<null>"));
  out << ")";
}


ItemVector3::~ItemVector3() noexcept {
}

ItemVector3::ItemVector3() noexcept
   : x(0),
     y(0),
     z(0) {
}

void ItemVector3::__set_x(const double val) {
  this->x = val;
}

void ItemVector3::__set_y(const double val) {
  this->y = val;
}

void ItemVector3::__set_z(const double val) {
  this->z = val;
}
std::ostream& operator<<(std::ostream& out, const ItemVector3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ItemVector3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemVector3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemVector3");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemVector3 &a, ItemVector3 &b) noexcept {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

bool ItemVector3::operator==(const ItemVector3 & rhs) const
{
  if (!(x == rhs.x))
    return false;
  if (!(y == rhs.y))
    return false;
  if (!(z == rhs.z))
    return false;
  return true;
}

ItemVector3::ItemVector3(const ItemVector3& other2) noexcept {
  x = other2.x;
  y = other2.y;
  z = other2.z;
  __isset = other2.__isset;
}
ItemVector3& ItemVector3::operator=(const ItemVector3& other3) noexcept {
  x = other3.x;
  y = other3.y;
  z = other3.z;
  __isset = other3.__isset;
  return *this;
}
void ItemVector3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemVector3(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


AttributeValue::~AttributeValue() noexcept {
}

AttributeValue::AttributeValue() noexcept
   : bool_value(0),
     double_value(0),
     asset_id(0) {
}

void AttributeValue::__set_bool_value(const bool val) {
  this->bool_value = val;
__isset.bool_value = true;
}

void AttributeValue::__set_double_value(const double val) {
  this->double_value = val;
__isset.double_value = true;
}

void AttributeValue::__set_vector3(const ItemVector3& val) {
  this->vector3 = val;
__isset.vector3 = true;
}

void AttributeValue::__set_asset_id(const AssetId val) {
  this->asset_id = val;
__isset.asset_id = true;
}
std::ostream& operator<<(std::ostream& out, const AttributeValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AttributeValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bool_value);
          this->__isset.bool_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->double_value);
          this->__isset.double_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vector3.read(iprot);
          this->__isset.vector3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->asset_id);
          this->__isset.asset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AttributeValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AttributeValue");

  if (this->__isset.bool_value) {
    xfer += oprot->writeFieldBegin("bool_value", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->bool_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.double_value) {
    xfer += oprot->writeFieldBegin("double_value", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->double_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vector3) {
    xfer += oprot->writeFieldBegin("vector3", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->vector3.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.asset_id) {
    xfer += oprot->writeFieldBegin("asset_id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->asset_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AttributeValue &a, AttributeValue &b) noexcept {
  using ::std::swap;
  swap(a.bool_value, b.bool_value);
  swap(a.double_value, b.double_value);
  swap(a.vector3, b.vector3);
  swap(a.asset_id, b.asset_id);
  swap(a.__isset, b.__isset);
}

bool AttributeValue::operator==(const AttributeValue & rhs) const
{
  if (__isset.bool_value != rhs.__isset.bool_value)
    return false;
  else if (__isset.bool_value && !(bool_value == rhs.bool_value))
    return false;
  if (__isset.double_value != rhs.__isset.double_value)
    return false;
  else if (__isset.double_value && !(double_value == rhs.double_value))
    return false;
  if (__isset.vector3 != rhs.__isset.vector3)
    return false;
  else if (__isset.vector3 && !(vector3 == rhs.vector3))
    return false;
  if (__isset.asset_id != rhs.__isset.asset_id)
    return false;
  else if (__isset.asset_id && !(asset_id == rhs.asset_id))
    return false;
  return true;
}

AttributeValue::AttributeValue(const AttributeValue& other4) noexcept {
  bool_value = other4.bool_value;
  double_value = other4.double_value;
  vector3 = other4.vector3;
  asset_id = other4.asset_id;
  __isset = other4.__isset;
}
AttributeValue& AttributeValue::operator=(const AttributeValue& other5) noexcept {
  bool_value = other5.bool_value;
  double_value = other5.double_value;
  vector3 = other5.vector3;
  asset_id = other5.asset_id;
  __isset = other5.__isset;
  return *this;
}
void AttributeValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AttributeValue(";
  out << "bool_value="; (__isset.bool_value ? (out << to_string(bool_value)) : (out << "<null>"));
  out << ", " << "double_value="; (__isset.double_value ? (out << to_string(double_value)) : (out << "<null>"));
  out << ", " << "vector3="; (__isset.vector3 ? (out << to_string(vector3)) : (out << "<null>"));
  out << ", " << "asset_id="; (__isset.asset_id ? (out << to_string(asset_id)) : (out << "<null>"));
  out << ")";
}


Attribute::~Attribute() noexcept {
}

Attribute::Attribute() noexcept
   : id(0),
     internal_name(),
     visible(0),
     attribute_type(static_cast<AttributeType::type>(0)) {
}

void Attribute::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void Attribute::__set_internal_name(const std::string& val) {
  this->internal_name = val;
}

void Attribute::__set_visible(const bool val) {
  this->visible = val;
}

void Attribute::__set_value(const AttributeValue& val) {
  this->value = val;
}

void Attribute::__set_attribute_type(const AttributeType::type val) {
  this->attribute_type = val;
}

void Attribute::__set_owner(const Owner& val) {
  this->owner = val;
}
std::ostream& operator<<(std::ostream& out, const Attribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Attribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->internal_name);
          this->__isset.internal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->visible);
          this->__isset.visible = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->attribute_type = static_cast<AttributeType::type>(ecast6);
          this->__isset.attribute_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->owner.read(iprot);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Attribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Attribute");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("internal_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->internal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visible", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->visible);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attribute_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->attribute_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->owner.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Attribute &a, Attribute &b) noexcept {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.internal_name, b.internal_name);
  swap(a.visible, b.visible);
  swap(a.value, b.value);
  swap(a.attribute_type, b.attribute_type);
  swap(a.owner, b.owner);
  swap(a.__isset, b.__isset);
}

bool Attribute::operator==(const Attribute & rhs) const
{
  if (__isset.id != rhs.__isset.id)
    return false;
  else if (__isset.id && !(id == rhs.id))
    return false;
  if (!(internal_name == rhs.internal_name))
    return false;
  if (!(visible == rhs.visible))
    return false;
  if (!(value == rhs.value))
    return false;
  if (!(attribute_type == rhs.attribute_type))
    return false;
  if (!(owner == rhs.owner))
    return false;
  return true;
}

Attribute::Attribute(const Attribute& other7) {
  id = other7.id;
  internal_name = other7.internal_name;
  visible = other7.visible;
  value = other7.value;
  attribute_type = other7.attribute_type;
  owner = other7.owner;
  __isset = other7.__isset;
}
Attribute& Attribute::operator=(const Attribute& other8) {
  id = other8.id;
  internal_name = other8.internal_name;
  visible = other8.visible;
  value = other8.value;
  attribute_type = other8.attribute_type;
  owner = other8.owner;
  __isset = other8.__isset;
  return *this;
}
void Attribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Attribute(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "internal_name=" << to_string(internal_name);
  out << ", " << "visible=" << to_string(visible);
  out << ", " << "value=" << to_string(value);
  out << ", " << "attribute_type=" << to_string(attribute_type);
  out << ", " << "owner=" << to_string(owner);
  out << ")";
}


Item::~Item() noexcept {
}

Item::Item() noexcept
   : id(0),
     internal_name(),
     max_stack_size(0),
     item_type(static_cast<ItemType::type>(0)) {
}

void Item::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void Item::__set_internal_name(const std::string& val) {
  this->internal_name = val;
}

void Item::__set_attributes(const std::map<AttributeType::type, Attribute> & val) {
  this->attributes = val;
}

void Item::__set_max_stack_size(const int64_t val) {
  this->max_stack_size = val;
__isset.max_stack_size = true;
}

void Item::__set_item_type(const ItemType::type val) {
  this->item_type = val;
}

void Item::__set_blueprint(const ItemBlueprint& val) {
  this->blueprint = val;
__isset.blueprint = true;
}
std::ostream& operator<<(std::ostream& out, const Item& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Item::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->internal_name);
          this->__isset.internal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              AttributeType::type _key14;
              int32_t ecast16;
              xfer += iprot->readI32(ecast16);
              _key14 = static_cast<AttributeType::type>(ecast16);
              Attribute& _val15 = this->attributes[_key14];
              xfer += _val15.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_stack_size);
          this->__isset.max_stack_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->item_type = static_cast<ItemType::type>(ecast17);
          this->__isset.item_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->blueprint.read(iprot);
          this->__isset.blueprint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Item::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Item");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("internal_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->internal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
    std::map<AttributeType::type, Attribute> ::const_iterator _iter18;
    for (_iter18 = this->attributes.begin(); _iter18 != this->attributes.end(); ++_iter18)
    {
      xfer += oprot->writeI32(static_cast<int32_t>(_iter18->first));
      xfer += _iter18->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.max_stack_size) {
    xfer += oprot->writeFieldBegin("max_stack_size", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->max_stack_size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("item_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->item_type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.blueprint) {
    xfer += oprot->writeFieldBegin("blueprint", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->blueprint.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Item &a, Item &b) noexcept {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.internal_name, b.internal_name);
  swap(a.attributes, b.attributes);
  swap(a.max_stack_size, b.max_stack_size);
  swap(a.item_type, b.item_type);
  swap(a.blueprint, b.blueprint);
  swap(a.__isset, b.__isset);
}

bool Item::operator==(const Item & rhs) const
{
  if (__isset.id != rhs.__isset.id)
    return false;
  else if (__isset.id && !(id == rhs.id))
    return false;
  if (!(internal_name == rhs.internal_name))
    return false;
  if (!(attributes == rhs.attributes))
    return false;
  if (__isset.max_stack_size != rhs.__isset.max_stack_size)
    return false;
  else if (__isset.max_stack_size && !(max_stack_size == rhs.max_stack_size))
    return false;
  if (!(item_type == rhs.item_type))
    return false;
  if (__isset.blueprint != rhs.__isset.blueprint)
    return false;
  else if (__isset.blueprint && !(blueprint == rhs.blueprint))
    return false;
  return true;
}

Item::Item(const Item& other19) {
  id = other19.id;
  internal_name = other19.internal_name;
  attributes = other19.attributes;
  max_stack_size = other19.max_stack_size;
  item_type = other19.item_type;
  blueprint = other19.blueprint;
  __isset = other19.__isset;
}
Item& Item::operator=(const Item& other20) {
  id = other20.id;
  internal_name = other20.internal_name;
  attributes = other20.attributes;
  max_stack_size = other20.max_stack_size;
  item_type = other20.item_type;
  blueprint = other20.blueprint;
  __isset = other20.__isset;
  return *this;
}
void Item::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Item(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "internal_name=" << to_string(internal_name);
  out << ", " << "attributes=" << to_string(attributes);
  out << ", " << "max_stack_size="; (__isset.max_stack_size ? (out << to_string(max_stack_size)) : (out << "<null>"));
  out << ", " << "item_type=" << to_string(item_type);
  out << ", " << "blueprint="; (__isset.blueprint ? (out << to_string(blueprint)) : (out << "<null>"));
  out << ")";
}


ItemBlueprintComponent::~ItemBlueprintComponent() noexcept {
}

ItemBlueprintComponent::ItemBlueprintComponent() noexcept
   : ratio(0),
     item_id(0) {
}

void ItemBlueprintComponent::__set_ratio(const double val) {
  this->ratio = val;
}

void ItemBlueprintComponent::__set_item_id(const ItemId val) {
  this->item_id = val;
}
std::ostream& operator<<(std::ostream& out, const ItemBlueprintComponent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ItemBlueprintComponent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ratio);
          this->__isset.ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->item_id);
          this->__isset.item_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemBlueprintComponent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemBlueprintComponent");

  xfer += oprot->writeFieldBegin("ratio", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->ratio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->item_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemBlueprintComponent &a, ItemBlueprintComponent &b) noexcept {
  using ::std::swap;
  swap(a.ratio, b.ratio);
  swap(a.item_id, b.item_id);
  swap(a.__isset, b.__isset);
}

bool ItemBlueprintComponent::operator==(const ItemBlueprintComponent & rhs) const
{
  if (!(ratio == rhs.ratio))
    return false;
  if (!(item_id == rhs.item_id))
    return false;
  return true;
}

ItemBlueprintComponent::ItemBlueprintComponent(const ItemBlueprintComponent& other21) noexcept {
  ratio = other21.ratio;
  item_id = other21.item_id;
  __isset = other21.__isset;
}
ItemBlueprintComponent& ItemBlueprintComponent::operator=(const ItemBlueprintComponent& other22) noexcept {
  ratio = other22.ratio;
  item_id = other22.item_id;
  __isset = other22.__isset;
  return *this;
}
void ItemBlueprintComponent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemBlueprintComponent(";
  out << "ratio=" << to_string(ratio);
  out << ", " << "item_id=" << to_string(item_id);
  out << ")";
}


ItemBlueprint::~ItemBlueprint() noexcept {
}

ItemBlueprint::ItemBlueprint() noexcept
   : id(0),
     bake_time_ms(0) {
}

void ItemBlueprint::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void ItemBlueprint::__set_components(const std::map<ItemId, ItemBlueprintComponent> & val) {
  this->components = val;
}

void ItemBlueprint::__set_bake_time_ms(const int64_t val) {
  this->bake_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const ItemBlueprint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ItemBlueprint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->components.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _ktype24;
            ::apache::thrift::protocol::TType _vtype25;
            xfer += iprot->readMapBegin(_ktype24, _vtype25, _size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              ItemId _key28;
              xfer += iprot->readI64(_key28);
              ItemBlueprintComponent& _val29 = this->components[_key28];
              xfer += _val29.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.components = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bake_time_ms);
          this->__isset.bake_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemBlueprint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemBlueprint");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("components", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->components.size()));
    std::map<ItemId, ItemBlueprintComponent> ::const_iterator _iter30;
    for (_iter30 = this->components.begin(); _iter30 != this->components.end(); ++_iter30)
    {
      xfer += oprot->writeI64(_iter30->first);
      xfer += _iter30->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bake_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->bake_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemBlueprint &a, ItemBlueprint &b) noexcept {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.components, b.components);
  swap(a.bake_time_ms, b.bake_time_ms);
  swap(a.__isset, b.__isset);
}

bool ItemBlueprint::operator==(const ItemBlueprint & rhs) const
{
  if (__isset.id != rhs.__isset.id)
    return false;
  else if (__isset.id && !(id == rhs.id))
    return false;
  if (!(components == rhs.components))
    return false;
  if (!(bake_time_ms == rhs.bake_time_ms))
    return false;
  return true;
}

ItemBlueprint::ItemBlueprint(const ItemBlueprint& other31) {
  id = other31.id;
  components = other31.components;
  bake_time_ms = other31.bake_time_ms;
  __isset = other31.__isset;
}
ItemBlueprint& ItemBlueprint::operator=(const ItemBlueprint& other32) {
  id = other32.id;
  components = other32.components;
  bake_time_ms = other32.bake_time_ms;
  __isset = other32.__isset;
  return *this;
}
void ItemBlueprint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemBlueprint(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "components=" << to_string(components);
  out << ", " << "bake_time_ms=" << to_string(bake_time_ms);
  out << ")";
}


ItemDb::~ItemDb() noexcept {
}

ItemDb::ItemDb() noexcept {
}

void ItemDb::__set_items(const std::vector<Item> & val) {
  this->items = val;
}
std::ostream& operator<<(std::ostream& out, const ItemDb& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ItemDb::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->items.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->items.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->items[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemDb::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemDb");

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->items.size()));
    std::vector<Item> ::const_iterator _iter38;
    for (_iter38 = this->items.begin(); _iter38 != this->items.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemDb &a, ItemDb &b) noexcept {
  using ::std::swap;
  swap(a.items, b.items);
  swap(a.__isset, b.__isset);
}

bool ItemDb::operator==(const ItemDb & rhs) const
{
  if (!(items == rhs.items))
    return false;
  return true;
}

ItemDb::ItemDb(const ItemDb& other39) {
  items = other39.items;
  __isset = other39.__isset;
}
ItemDb& ItemDb::operator=(const ItemDb& other40) {
  items = other40.items;
  __isset = other40.__isset;
  return *this;
}
void ItemDb::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemDb(";
  out << "items=" << to_string(items);
  out << ")";
}


InventoryEntry::~InventoryEntry() noexcept {
}

InventoryEntry::InventoryEntry() noexcept
   : item_id(0),
     quantity(0),
     is_max_stacked(false) {
}

void InventoryEntry::__set_item_id(const ItemId val) {
  this->item_id = val;
}

void InventoryEntry::__set_quantity(const double val) {
  this->quantity = val;
}

void InventoryEntry::__set_is_max_stacked(const bool val) {
  this->is_max_stacked = val;
}
std::ostream& operator<<(std::ostream& out, const InventoryEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InventoryEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->item_id);
          this->__isset.item_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_max_stacked);
          this->__isset.is_max_stacked = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InventoryEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InventoryEntry");

  xfer += oprot->writeFieldBegin("item_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->item_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_max_stacked", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_max_stacked);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InventoryEntry &a, InventoryEntry &b) noexcept {
  using ::std::swap;
  swap(a.item_id, b.item_id);
  swap(a.quantity, b.quantity);
  swap(a.is_max_stacked, b.is_max_stacked);
  swap(a.__isset, b.__isset);
}

bool InventoryEntry::operator==(const InventoryEntry & rhs) const
{
  if (!(item_id == rhs.item_id))
    return false;
  if (!(quantity == rhs.quantity))
    return false;
  if (!(is_max_stacked == rhs.is_max_stacked))
    return false;
  return true;
}

InventoryEntry::InventoryEntry(const InventoryEntry& other41) noexcept {
  item_id = other41.item_id;
  quantity = other41.quantity;
  is_max_stacked = other41.is_max_stacked;
  __isset = other41.__isset;
}
InventoryEntry& InventoryEntry::operator=(const InventoryEntry& other42) noexcept {
  item_id = other42.item_id;
  quantity = other42.quantity;
  is_max_stacked = other42.is_max_stacked;
  __isset = other42.__isset;
  return *this;
}
void InventoryEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InventoryEntry(";
  out << "item_id=" << to_string(item_id);
  out << ", " << "quantity=" << to_string(quantity);
  out << ", " << "is_max_stacked=" << to_string(is_max_stacked);
  out << ")";
}


Inventory::~Inventory() noexcept {
}

Inventory::Inventory() noexcept
   : id(0),
     max_entries(0),
     max_volume(0),
     last_calculated_volume(0.0000000000000000) {
}

void Inventory::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void Inventory::__set_max_entries(const int64_t val) {
  this->max_entries = val;
}

void Inventory::__set_max_volume(const double val) {
  this->max_volume = val;
}

void Inventory::__set_entries(const std::vector<InventoryEntry> & val) {
  this->entries = val;
}

void Inventory::__set_last_calculated_volume(const double val) {
  this->last_calculated_volume = val;
}

void Inventory::__set_owner(const Owner& val) {
  this->owner = val;
}
std::ostream& operator<<(std::ostream& out, const Inventory& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Inventory::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_entries);
          this->__isset.max_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max_volume);
          this->__isset.max_volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entries.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->entries.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->entries[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->last_calculated_volume);
          this->__isset.last_calculated_volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->owner.read(iprot);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Inventory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Inventory");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("max_entries", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max_entries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_volume", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->max_volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entries.size()));
    std::vector<InventoryEntry> ::const_iterator _iter48;
    for (_iter48 = this->entries.begin(); _iter48 != this->entries.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_calculated_volume", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->last_calculated_volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->owner.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Inventory &a, Inventory &b) noexcept {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.max_entries, b.max_entries);
  swap(a.max_volume, b.max_volume);
  swap(a.entries, b.entries);
  swap(a.last_calculated_volume, b.last_calculated_volume);
  swap(a.owner, b.owner);
  swap(a.__isset, b.__isset);
}

bool Inventory::operator==(const Inventory & rhs) const
{
  if (__isset.id != rhs.__isset.id)
    return false;
  else if (__isset.id && !(id == rhs.id))
    return false;
  if (!(max_entries == rhs.max_entries))
    return false;
  if (!(max_volume == rhs.max_volume))
    return false;
  if (!(entries == rhs.entries))
    return false;
  if (!(last_calculated_volume == rhs.last_calculated_volume))
    return false;
  if (!(owner == rhs.owner))
    return false;
  return true;
}

Inventory::Inventory(const Inventory& other49) {
  id = other49.id;
  max_entries = other49.max_entries;
  max_volume = other49.max_volume;
  entries = other49.entries;
  last_calculated_volume = other49.last_calculated_volume;
  owner = other49.owner;
  __isset = other49.__isset;
}
Inventory& Inventory::operator=(const Inventory& other50) {
  id = other50.id;
  max_entries = other50.max_entries;
  max_volume = other50.max_volume;
  entries = other50.entries;
  last_calculated_volume = other50.last_calculated_volume;
  owner = other50.owner;
  __isset = other50.__isset;
  return *this;
}
void Inventory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Inventory(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "max_entries=" << to_string(max_entries);
  out << ", " << "max_volume=" << to_string(max_volume);
  out << ", " << "entries=" << to_string(entries);
  out << ", " << "last_calculated_volume=" << to_string(last_calculated_volume);
  out << ", " << "owner=" << to_string(owner);
  out << ")";
}


GameResult::~GameResult() noexcept {
}

GameResult::GameResult() noexcept
   : status(static_cast<StatusType::type>(0)),
     message(),
     error_code(static_cast<GameError::type>(0)) {
}

void GameResult::__set_status(const StatusType::type val) {
  this->status = val;
}

void GameResult::__set_message(const std::string& val) {
  this->message = val;
}

void GameResult::__set_error_code(const GameError::type val) {
  this->error_code = val;
__isset.error_code = true;
}
std::ostream& operator<<(std::ostream& out, const GameResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GameResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->status = static_cast<StatusType::type>(ecast51);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->error_code = static_cast<GameError::type>(ecast52);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GameResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GameResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->status));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error_code) {
    xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->error_code));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GameResult &a, GameResult &b) noexcept {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.message, b.message);
  swap(a.error_code, b.error_code);
  swap(a.__isset, b.__isset);
}

bool GameResult::operator==(const GameResult & rhs) const
{
  if (!(status == rhs.status))
    return false;
  if (!(message == rhs.message))
    return false;
  if (__isset.error_code != rhs.__isset.error_code)
    return false;
  else if (__isset.error_code && !(error_code == rhs.error_code))
    return false;
  return true;
}

GameResult::GameResult(const GameResult& other53) {
  status = other53.status;
  message = other53.message;
  error_code = other53.error_code;
  __isset = other53.__isset;
}
GameResult& GameResult::operator=(const GameResult& other54) {
  status = other54.status;
  message = other54.message;
  error_code = other54.error_code;
  __isset = other54.__isset;
  return *this;
}
void GameResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GameResult(";
  out << "status=" << to_string(status);
  out << ", " << "message=" << to_string(message);
  out << ", " << "error_code="; (__isset.error_code ? (out << to_string(error_code)) : (out << "<null>"));
  out << ")";
}


Mobile::~Mobile() noexcept {
}

Mobile::Mobile() noexcept
   : id(0),
     mobile_type(static_cast<MobileType::type>(0)) {
}

void Mobile::__set_id(const MobileId val) {
  this->id = val;
__isset.id = true;
}

void Mobile::__set_mobile_type(const MobileType::type val) {
  this->mobile_type = val;
}

void Mobile::__set_attributes(const std::map<AttributeType::type, Attribute> & val) {
  this->attributes = val;
}
std::ostream& operator<<(std::ostream& out, const Mobile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Mobile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast55;
          xfer += iprot->readI32(ecast55);
          this->mobile_type = static_cast<MobileType::type>(ecast55);
          this->__isset.mobile_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _ktype57;
            ::apache::thrift::protocol::TType _vtype58;
            xfer += iprot->readMapBegin(_ktype57, _vtype58, _size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              AttributeType::type _key61;
              int32_t ecast63;
              xfer += iprot->readI32(ecast63);
              _key61 = static_cast<AttributeType::type>(ecast63);
              Attribute& _val62 = this->attributes[_key61];
              xfer += _val62.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Mobile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Mobile");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("mobile_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->mobile_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
    std::map<AttributeType::type, Attribute> ::const_iterator _iter64;
    for (_iter64 = this->attributes.begin(); _iter64 != this->attributes.end(); ++_iter64)
    {
      xfer += oprot->writeI32(static_cast<int32_t>(_iter64->first));
      xfer += _iter64->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Mobile &a, Mobile &b) noexcept {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.mobile_type, b.mobile_type);
  swap(a.attributes, b.attributes);
  swap(a.__isset, b.__isset);
}

bool Mobile::operator==(const Mobile & rhs) const
{
  if (__isset.id != rhs.__isset.id)
    return false;
  else if (__isset.id && !(id == rhs.id))
    return false;
  if (!(mobile_type == rhs.mobile_type))
    return false;
  if (!(attributes == rhs.attributes))
    return false;
  return true;
}

Mobile::Mobile(const Mobile& other65) {
  id = other65.id;
  mobile_type = other65.mobile_type;
  attributes = other65.attributes;
  __isset = other65.__isset;
}
Mobile& Mobile::operator=(const Mobile& other66) {
  id = other66.id;
  mobile_type = other66.mobile_type;
  attributes = other66.attributes;
  __isset = other66.__isset;
  return *this;
}
void Mobile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Mobile(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "mobile_type=" << to_string(mobile_type);
  out << ", " << "attributes=" << to_string(attributes);
  out << ")";
}


LoadInventoryRequestData::~LoadInventoryRequestData() noexcept {
}

LoadInventoryRequestData::LoadInventoryRequestData() noexcept
   : inventory_id(0) {
}

void LoadInventoryRequestData::__set_inventory_id(const int64_t val) {
  this->inventory_id = val;
}
std::ostream& operator<<(std::ostream& out, const LoadInventoryRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoadInventoryRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->inventory_id);
          this->__isset.inventory_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoadInventoryRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoadInventoryRequestData");

  xfer += oprot->writeFieldBegin("inventory_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->inventory_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoadInventoryRequestData &a, LoadInventoryRequestData &b) noexcept {
  using ::std::swap;
  swap(a.inventory_id, b.inventory_id);
  swap(a.__isset, b.__isset);
}

bool LoadInventoryRequestData::operator==(const LoadInventoryRequestData & rhs) const
{
  if (!(inventory_id == rhs.inventory_id))
    return false;
  return true;
}

LoadInventoryRequestData::LoadInventoryRequestData(const LoadInventoryRequestData& other67) noexcept {
  inventory_id = other67.inventory_id;
  __isset = other67.__isset;
}
LoadInventoryRequestData& LoadInventoryRequestData::operator=(const LoadInventoryRequestData& other68) noexcept {
  inventory_id = other68.inventory_id;
  __isset = other68.__isset;
  return *this;
}
void LoadInventoryRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoadInventoryRequestData(";
  out << "inventory_id=" << to_string(inventory_id);
  out << ")";
}


CreateInventoryRequestData::~CreateInventoryRequestData() noexcept {
}

CreateInventoryRequestData::CreateInventoryRequestData() noexcept {
}

void CreateInventoryRequestData::__set_inventory(const Inventory& val) {
  this->inventory = val;
}
std::ostream& operator<<(std::ostream& out, const CreateInventoryRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateInventoryRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->inventory.read(iprot);
          this->__isset.inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateInventoryRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateInventoryRequestData");

  xfer += oprot->writeFieldBegin("inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateInventoryRequestData &a, CreateInventoryRequestData &b) noexcept {
  using ::std::swap;
  swap(a.inventory, b.inventory);
  swap(a.__isset, b.__isset);
}

bool CreateInventoryRequestData::operator==(const CreateInventoryRequestData & rhs) const
{
  if (!(inventory == rhs.inventory))
    return false;
  return true;
}

CreateInventoryRequestData::CreateInventoryRequestData(const CreateInventoryRequestData& other69) {
  inventory = other69.inventory;
  __isset = other69.__isset;
}
CreateInventoryRequestData& CreateInventoryRequestData::operator=(const CreateInventoryRequestData& other70) {
  inventory = other70.inventory;
  __isset = other70.__isset;
  return *this;
}
void CreateInventoryRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateInventoryRequestData(";
  out << "inventory=" << to_string(inventory);
  out << ")";
}


SaveInventoryRequestData::~SaveInventoryRequestData() noexcept {
}

SaveInventoryRequestData::SaveInventoryRequestData() noexcept {
}

void SaveInventoryRequestData::__set_inventory(const Inventory& val) {
  this->inventory = val;
}
std::ostream& operator<<(std::ostream& out, const SaveInventoryRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SaveInventoryRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->inventory.read(iprot);
          this->__isset.inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SaveInventoryRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SaveInventoryRequestData");

  xfer += oprot->writeFieldBegin("inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SaveInventoryRequestData &a, SaveInventoryRequestData &b) noexcept {
  using ::std::swap;
  swap(a.inventory, b.inventory);
  swap(a.__isset, b.__isset);
}

bool SaveInventoryRequestData::operator==(const SaveInventoryRequestData & rhs) const
{
  if (!(inventory == rhs.inventory))
    return false;
  return true;
}

SaveInventoryRequestData::SaveInventoryRequestData(const SaveInventoryRequestData& other71) {
  inventory = other71.inventory;
  __isset = other71.__isset;
}
SaveInventoryRequestData& SaveInventoryRequestData::operator=(const SaveInventoryRequestData& other72) {
  inventory = other72.inventory;
  __isset = other72.__isset;
  return *this;
}
void SaveInventoryRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SaveInventoryRequestData(";
  out << "inventory=" << to_string(inventory);
  out << ")";
}


SplitStackRequestData::~SplitStackRequestData() noexcept {
}

SplitStackRequestData::SplitStackRequestData() noexcept
   : inventory_id(0),
     item_id(0),
     quantity_to_split(0) {
}

void SplitStackRequestData::__set_inventory_id(const int64_t val) {
  this->inventory_id = val;
}

void SplitStackRequestData::__set_item_id(const int64_t val) {
  this->item_id = val;
}

void SplitStackRequestData::__set_quantity_to_split(const double val) {
  this->quantity_to_split = val;
}
std::ostream& operator<<(std::ostream& out, const SplitStackRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SplitStackRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->inventory_id);
          this->__isset.inventory_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->item_id);
          this->__isset.item_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->quantity_to_split);
          this->__isset.quantity_to_split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SplitStackRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SplitStackRequestData");

  xfer += oprot->writeFieldBegin("inventory_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->inventory_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->item_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity_to_split", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->quantity_to_split);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SplitStackRequestData &a, SplitStackRequestData &b) noexcept {
  using ::std::swap;
  swap(a.inventory_id, b.inventory_id);
  swap(a.item_id, b.item_id);
  swap(a.quantity_to_split, b.quantity_to_split);
  swap(a.__isset, b.__isset);
}

bool SplitStackRequestData::operator==(const SplitStackRequestData & rhs) const
{
  if (!(inventory_id == rhs.inventory_id))
    return false;
  if (!(item_id == rhs.item_id))
    return false;
  if (!(quantity_to_split == rhs.quantity_to_split))
    return false;
  return true;
}

SplitStackRequestData::SplitStackRequestData(const SplitStackRequestData& other73) noexcept {
  inventory_id = other73.inventory_id;
  item_id = other73.item_id;
  quantity_to_split = other73.quantity_to_split;
  __isset = other73.__isset;
}
SplitStackRequestData& SplitStackRequestData::operator=(const SplitStackRequestData& other74) noexcept {
  inventory_id = other74.inventory_id;
  item_id = other74.item_id;
  quantity_to_split = other74.quantity_to_split;
  __isset = other74.__isset;
  return *this;
}
void SplitStackRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SplitStackRequestData(";
  out << "inventory_id=" << to_string(inventory_id);
  out << ", " << "item_id=" << to_string(item_id);
  out << ", " << "quantity_to_split=" << to_string(quantity_to_split);
  out << ")";
}


TransferItemRequestData::~TransferItemRequestData() noexcept {
}

TransferItemRequestData::TransferItemRequestData() noexcept
   : source_inventory_id(0),
     destination_inventory_id(0),
     item_id(0),
     quantity(0) {
}

void TransferItemRequestData::__set_source_inventory_id(const int64_t val) {
  this->source_inventory_id = val;
}

void TransferItemRequestData::__set_destination_inventory_id(const int64_t val) {
  this->destination_inventory_id = val;
}

void TransferItemRequestData::__set_item_id(const int64_t val) {
  this->item_id = val;
}

void TransferItemRequestData::__set_quantity(const double val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const TransferItemRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransferItemRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->source_inventory_id);
          this->__isset.source_inventory_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->destination_inventory_id);
          this->__isset.destination_inventory_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->item_id);
          this->__isset.item_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransferItemRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransferItemRequestData");

  xfer += oprot->writeFieldBegin("source_inventory_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->source_inventory_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destination_inventory_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->destination_inventory_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->item_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransferItemRequestData &a, TransferItemRequestData &b) noexcept {
  using ::std::swap;
  swap(a.source_inventory_id, b.source_inventory_id);
  swap(a.destination_inventory_id, b.destination_inventory_id);
  swap(a.item_id, b.item_id);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

bool TransferItemRequestData::operator==(const TransferItemRequestData & rhs) const
{
  if (!(source_inventory_id == rhs.source_inventory_id))
    return false;
  if (!(destination_inventory_id == rhs.destination_inventory_id))
    return false;
  if (!(item_id == rhs.item_id))
    return false;
  if (!(quantity == rhs.quantity))
    return false;
  return true;
}

TransferItemRequestData::TransferItemRequestData(const TransferItemRequestData& other75) noexcept {
  source_inventory_id = other75.source_inventory_id;
  destination_inventory_id = other75.destination_inventory_id;
  item_id = other75.item_id;
  quantity = other75.quantity;
  __isset = other75.__isset;
}
TransferItemRequestData& TransferItemRequestData::operator=(const TransferItemRequestData& other76) noexcept {
  source_inventory_id = other76.source_inventory_id;
  destination_inventory_id = other76.destination_inventory_id;
  item_id = other76.item_id;
  quantity = other76.quantity;
  __isset = other76.__isset;
  return *this;
}
void TransferItemRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransferItemRequestData(";
  out << "source_inventory_id=" << to_string(source_inventory_id);
  out << ", " << "destination_inventory_id=" << to_string(destination_inventory_id);
  out << ", " << "item_id=" << to_string(item_id);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


LoadInventoryResponseData::~LoadInventoryResponseData() noexcept {
}

LoadInventoryResponseData::LoadInventoryResponseData() noexcept {
}

void LoadInventoryResponseData::__set_inventory(const Inventory& val) {
  this->inventory = val;
}
std::ostream& operator<<(std::ostream& out, const LoadInventoryResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoadInventoryResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->inventory.read(iprot);
          this->__isset.inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoadInventoryResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoadInventoryResponseData");

  xfer += oprot->writeFieldBegin("inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoadInventoryResponseData &a, LoadInventoryResponseData &b) noexcept {
  using ::std::swap;
  swap(a.inventory, b.inventory);
  swap(a.__isset, b.__isset);
}

bool LoadInventoryResponseData::operator==(const LoadInventoryResponseData & rhs) const
{
  if (!(inventory == rhs.inventory))
    return false;
  return true;
}

LoadInventoryResponseData::LoadInventoryResponseData(const LoadInventoryResponseData& other77) {
  inventory = other77.inventory;
  __isset = other77.__isset;
}
LoadInventoryResponseData& LoadInventoryResponseData::operator=(const LoadInventoryResponseData& other78) {
  inventory = other78.inventory;
  __isset = other78.__isset;
  return *this;
}
void LoadInventoryResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoadInventoryResponseData(";
  out << "inventory=" << to_string(inventory);
  out << ")";
}


CreateInventoryResponseData::~CreateInventoryResponseData() noexcept {
}

CreateInventoryResponseData::CreateInventoryResponseData() noexcept {
}

void CreateInventoryResponseData::__set_inventory(const Inventory& val) {
  this->inventory = val;
}
std::ostream& operator<<(std::ostream& out, const CreateInventoryResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateInventoryResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->inventory.read(iprot);
          this->__isset.inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateInventoryResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateInventoryResponseData");

  xfer += oprot->writeFieldBegin("inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateInventoryResponseData &a, CreateInventoryResponseData &b) noexcept {
  using ::std::swap;
  swap(a.inventory, b.inventory);
  swap(a.__isset, b.__isset);
}

bool CreateInventoryResponseData::operator==(const CreateInventoryResponseData & rhs) const
{
  if (!(inventory == rhs.inventory))
    return false;
  return true;
}

CreateInventoryResponseData::CreateInventoryResponseData(const CreateInventoryResponseData& other79) {
  inventory = other79.inventory;
  __isset = other79.__isset;
}
CreateInventoryResponseData& CreateInventoryResponseData::operator=(const CreateInventoryResponseData& other80) {
  inventory = other80.inventory;
  __isset = other80.__isset;
  return *this;
}
void CreateInventoryResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateInventoryResponseData(";
  out << "inventory=" << to_string(inventory);
  out << ")";
}


SaveInventoryResponseData::~SaveInventoryResponseData() noexcept {
}

SaveInventoryResponseData::SaveInventoryResponseData() noexcept {
}

void SaveInventoryResponseData::__set_inventory(const Inventory& val) {
  this->inventory = val;
}
std::ostream& operator<<(std::ostream& out, const SaveInventoryResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SaveInventoryResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->inventory.read(iprot);
          this->__isset.inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SaveInventoryResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SaveInventoryResponseData");

  xfer += oprot->writeFieldBegin("inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SaveInventoryResponseData &a, SaveInventoryResponseData &b) noexcept {
  using ::std::swap;
  swap(a.inventory, b.inventory);
  swap(a.__isset, b.__isset);
}

bool SaveInventoryResponseData::operator==(const SaveInventoryResponseData & rhs) const
{
  if (!(inventory == rhs.inventory))
    return false;
  return true;
}

SaveInventoryResponseData::SaveInventoryResponseData(const SaveInventoryResponseData& other81) {
  inventory = other81.inventory;
  __isset = other81.__isset;
}
SaveInventoryResponseData& SaveInventoryResponseData::operator=(const SaveInventoryResponseData& other82) {
  inventory = other82.inventory;
  __isset = other82.__isset;
  return *this;
}
void SaveInventoryResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SaveInventoryResponseData(";
  out << "inventory=" << to_string(inventory);
  out << ")";
}


SplitStackResponseData::~SplitStackResponseData() noexcept {
}

SplitStackResponseData::SplitStackResponseData() noexcept {
}

void SplitStackResponseData::__set_inventory(const Inventory& val) {
  this->inventory = val;
}
std::ostream& operator<<(std::ostream& out, const SplitStackResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SplitStackResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->inventory.read(iprot);
          this->__isset.inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SplitStackResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SplitStackResponseData");

  xfer += oprot->writeFieldBegin("inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SplitStackResponseData &a, SplitStackResponseData &b) noexcept {
  using ::std::swap;
  swap(a.inventory, b.inventory);
  swap(a.__isset, b.__isset);
}

bool SplitStackResponseData::operator==(const SplitStackResponseData & rhs) const
{
  if (!(inventory == rhs.inventory))
    return false;
  return true;
}

SplitStackResponseData::SplitStackResponseData(const SplitStackResponseData& other83) {
  inventory = other83.inventory;
  __isset = other83.__isset;
}
SplitStackResponseData& SplitStackResponseData::operator=(const SplitStackResponseData& other84) {
  inventory = other84.inventory;
  __isset = other84.__isset;
  return *this;
}
void SplitStackResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SplitStackResponseData(";
  out << "inventory=" << to_string(inventory);
  out << ")";
}


TransferItemResponseData::~TransferItemResponseData() noexcept {
}

TransferItemResponseData::TransferItemResponseData() noexcept {
}

void TransferItemResponseData::__set_source_inventory(const Inventory& val) {
  this->source_inventory = val;
}

void TransferItemResponseData::__set_destination_inventory(const Inventory& val) {
  this->destination_inventory = val;
}
std::ostream& operator<<(std::ostream& out, const TransferItemResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransferItemResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->source_inventory.read(iprot);
          this->__isset.source_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->destination_inventory.read(iprot);
          this->__isset.destination_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransferItemResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransferItemResponseData");

  xfer += oprot->writeFieldBegin("source_inventory", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->source_inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destination_inventory", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->destination_inventory.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransferItemResponseData &a, TransferItemResponseData &b) noexcept {
  using ::std::swap;
  swap(a.source_inventory, b.source_inventory);
  swap(a.destination_inventory, b.destination_inventory);
  swap(a.__isset, b.__isset);
}

bool TransferItemResponseData::operator==(const TransferItemResponseData & rhs) const
{
  if (!(source_inventory == rhs.source_inventory))
    return false;
  if (!(destination_inventory == rhs.destination_inventory))
    return false;
  return true;
}

TransferItemResponseData::TransferItemResponseData(const TransferItemResponseData& other85) {
  source_inventory = other85.source_inventory;
  destination_inventory = other85.destination_inventory;
  __isset = other85.__isset;
}
TransferItemResponseData& TransferItemResponseData::operator=(const TransferItemResponseData& other86) {
  source_inventory = other86.source_inventory;
  destination_inventory = other86.destination_inventory;
  __isset = other86.__isset;
  return *this;
}
void TransferItemResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransferItemResponseData(";
  out << "source_inventory=" << to_string(source_inventory);
  out << ", " << "destination_inventory=" << to_string(destination_inventory);
  out << ")";
}


RequestData::~RequestData() noexcept {
}

RequestData::RequestData() noexcept {
}

void RequestData::__set_load_inventory(const LoadInventoryRequestData& val) {
  this->load_inventory = val;
__isset.load_inventory = true;
}

void RequestData::__set_create_inventory(const CreateInventoryRequestData& val) {
  this->create_inventory = val;
__isset.create_inventory = true;
}

void RequestData::__set_save_inventory(const SaveInventoryRequestData& val) {
  this->save_inventory = val;
__isset.save_inventory = true;
}

void RequestData::__set_split_stack(const SplitStackRequestData& val) {
  this->split_stack = val;
__isset.split_stack = true;
}

void RequestData::__set_transfer_item(const TransferItemRequestData& val) {
  this->transfer_item = val;
__isset.transfer_item = true;
}
std::ostream& operator<<(std::ostream& out, const RequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_inventory.read(iprot);
          this->__isset.load_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_inventory.read(iprot);
          this->__isset.create_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->save_inventory.read(iprot);
          this->__isset.save_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->split_stack.read(iprot);
          this->__isset.split_stack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transfer_item.read(iprot);
          this->__isset.transfer_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestData");

  if (this->__isset.load_inventory) {
    xfer += oprot->writeFieldBegin("load_inventory", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->load_inventory.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_inventory) {
    xfer += oprot->writeFieldBegin("create_inventory", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->create_inventory.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.save_inventory) {
    xfer += oprot->writeFieldBegin("save_inventory", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->save_inventory.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split_stack) {
    xfer += oprot->writeFieldBegin("split_stack", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->split_stack.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transfer_item) {
    xfer += oprot->writeFieldBegin("transfer_item", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->transfer_item.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestData &a, RequestData &b) noexcept {
  using ::std::swap;
  swap(a.load_inventory, b.load_inventory);
  swap(a.create_inventory, b.create_inventory);
  swap(a.save_inventory, b.save_inventory);
  swap(a.split_stack, b.split_stack);
  swap(a.transfer_item, b.transfer_item);
  swap(a.__isset, b.__isset);
}

bool RequestData::operator==(const RequestData & rhs) const
{
  if (__isset.load_inventory != rhs.__isset.load_inventory)
    return false;
  else if (__isset.load_inventory && !(load_inventory == rhs.load_inventory))
    return false;
  if (__isset.create_inventory != rhs.__isset.create_inventory)
    return false;
  else if (__isset.create_inventory && !(create_inventory == rhs.create_inventory))
    return false;
  if (__isset.save_inventory != rhs.__isset.save_inventory)
    return false;
  else if (__isset.save_inventory && !(save_inventory == rhs.save_inventory))
    return false;
  if (__isset.split_stack != rhs.__isset.split_stack)
    return false;
  else if (__isset.split_stack && !(split_stack == rhs.split_stack))
    return false;
  if (__isset.transfer_item != rhs.__isset.transfer_item)
    return false;
  else if (__isset.transfer_item && !(transfer_item == rhs.transfer_item))
    return false;
  return true;
}

RequestData::RequestData(const RequestData& other87) {
  load_inventory = other87.load_inventory;
  create_inventory = other87.create_inventory;
  save_inventory = other87.save_inventory;
  split_stack = other87.split_stack;
  transfer_item = other87.transfer_item;
  __isset = other87.__isset;
}
RequestData& RequestData::operator=(const RequestData& other88) {
  load_inventory = other88.load_inventory;
  create_inventory = other88.create_inventory;
  save_inventory = other88.save_inventory;
  split_stack = other88.split_stack;
  transfer_item = other88.transfer_item;
  __isset = other88.__isset;
  return *this;
}
void RequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestData(";
  out << "load_inventory="; (__isset.load_inventory ? (out << to_string(load_inventory)) : (out << "<null>"));
  out << ", " << "create_inventory="; (__isset.create_inventory ? (out << to_string(create_inventory)) : (out << "<null>"));
  out << ", " << "save_inventory="; (__isset.save_inventory ? (out << to_string(save_inventory)) : (out << "<null>"));
  out << ", " << "split_stack="; (__isset.split_stack ? (out << to_string(split_stack)) : (out << "<null>"));
  out << ", " << "transfer_item="; (__isset.transfer_item ? (out << to_string(transfer_item)) : (out << "<null>"));
  out << ")";
}


ResponseData::~ResponseData() noexcept {
}

ResponseData::ResponseData() noexcept {
}

void ResponseData::__set_load_inventory(const LoadInventoryResponseData& val) {
  this->load_inventory = val;
__isset.load_inventory = true;
}

void ResponseData::__set_create_inventory(const CreateInventoryResponseData& val) {
  this->create_inventory = val;
__isset.create_inventory = true;
}

void ResponseData::__set_save_inventory(const SaveInventoryResponseData& val) {
  this->save_inventory = val;
__isset.save_inventory = true;
}

void ResponseData::__set_split_stack(const SplitStackResponseData& val) {
  this->split_stack = val;
__isset.split_stack = true;
}

void ResponseData::__set_transfer_item(const TransferItemResponseData& val) {
  this->transfer_item = val;
__isset.transfer_item = true;
}
std::ostream& operator<<(std::ostream& out, const ResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_inventory.read(iprot);
          this->__isset.load_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_inventory.read(iprot);
          this->__isset.create_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->save_inventory.read(iprot);
          this->__isset.save_inventory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->split_stack.read(iprot);
          this->__isset.split_stack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transfer_item.read(iprot);
          this->__isset.transfer_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResponseData");

  if (this->__isset.load_inventory) {
    xfer += oprot->writeFieldBegin("load_inventory", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->load_inventory.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_inventory) {
    xfer += oprot->writeFieldBegin("create_inventory", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->create_inventory.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.save_inventory) {
    xfer += oprot->writeFieldBegin("save_inventory", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->save_inventory.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split_stack) {
    xfer += oprot->writeFieldBegin("split_stack", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->split_stack.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transfer_item) {
    xfer += oprot->writeFieldBegin("transfer_item", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->transfer_item.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResponseData &a, ResponseData &b) noexcept {
  using ::std::swap;
  swap(a.load_inventory, b.load_inventory);
  swap(a.create_inventory, b.create_inventory);
  swap(a.save_inventory, b.save_inventory);
  swap(a.split_stack, b.split_stack);
  swap(a.transfer_item, b.transfer_item);
  swap(a.__isset, b.__isset);
}

bool ResponseData::operator==(const ResponseData & rhs) const
{
  if (__isset.load_inventory != rhs.__isset.load_inventory)
    return false;
  else if (__isset.load_inventory && !(load_inventory == rhs.load_inventory))
    return false;
  if (__isset.create_inventory != rhs.__isset.create_inventory)
    return false;
  else if (__isset.create_inventory && !(create_inventory == rhs.create_inventory))
    return false;
  if (__isset.save_inventory != rhs.__isset.save_inventory)
    return false;
  else if (__isset.save_inventory && !(save_inventory == rhs.save_inventory))
    return false;
  if (__isset.split_stack != rhs.__isset.split_stack)
    return false;
  else if (__isset.split_stack && !(split_stack == rhs.split_stack))
    return false;
  if (__isset.transfer_item != rhs.__isset.transfer_item)
    return false;
  else if (__isset.transfer_item && !(transfer_item == rhs.transfer_item))
    return false;
  return true;
}

ResponseData::ResponseData(const ResponseData& other89) {
  load_inventory = other89.load_inventory;
  create_inventory = other89.create_inventory;
  save_inventory = other89.save_inventory;
  split_stack = other89.split_stack;
  transfer_item = other89.transfer_item;
  __isset = other89.__isset;
}
ResponseData& ResponseData::operator=(const ResponseData& other90) {
  load_inventory = other90.load_inventory;
  create_inventory = other90.create_inventory;
  save_inventory = other90.save_inventory;
  split_stack = other90.split_stack;
  transfer_item = other90.transfer_item;
  __isset = other90.__isset;
  return *this;
}
void ResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResponseData(";
  out << "load_inventory="; (__isset.load_inventory ? (out << to_string(load_inventory)) : (out << "<null>"));
  out << ", " << "create_inventory="; (__isset.create_inventory ? (out << to_string(create_inventory)) : (out << "<null>"));
  out << ", " << "save_inventory="; (__isset.save_inventory ? (out << to_string(save_inventory)) : (out << "<null>"));
  out << ", " << "split_stack="; (__isset.split_stack ? (out << to_string(split_stack)) : (out << "<null>"));
  out << ", " << "transfer_item="; (__isset.transfer_item ? (out << to_string(transfer_item)) : (out << "<null>"));
  out << ")";
}


Request::~Request() noexcept {
}

Request::Request() noexcept {
}

void Request::__set_data(const RequestData& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const Request& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Request::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Request");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Request &a, Request &b) noexcept {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

bool Request::operator==(const Request & rhs) const
{
  if (!(data == rhs.data))
    return false;
  return true;
}

Request::Request(const Request& other91) {
  data = other91.data;
  __isset = other91.__isset;
}
Request& Request::operator=(const Request& other92) {
  data = other92.data;
  __isset = other92.__isset;
  return *this;
}
void Request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Request(";
  out << "data=" << to_string(data);
  out << ")";
}


Response::~Response() noexcept {
}

Response::Response() noexcept {
}

void Response::__set_results(const std::vector<GameResult> & val) {
  this->results = val;
}

void Response::__set_response_data(const ResponseData& val) {
  this->response_data = val;
__isset.response_data = true;
}
std::ostream& operator<<(std::ostream& out, const Response& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Response::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->results.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->results[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response_data.read(iprot);
          this->__isset.response_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Response");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector<GameResult> ::const_iterator _iter98;
    for (_iter98 = this->results.begin(); _iter98 != this->results.end(); ++_iter98)
    {
      xfer += (*_iter98).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.response_data) {
    xfer += oprot->writeFieldBegin("response_data", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->response_data.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Response &a, Response &b) noexcept {
  using ::std::swap;
  swap(a.results, b.results);
  swap(a.response_data, b.response_data);
  swap(a.__isset, b.__isset);
}

bool Response::operator==(const Response & rhs) const
{
  if (!(results == rhs.results))
    return false;
  if (__isset.response_data != rhs.__isset.response_data)
    return false;
  else if (__isset.response_data && !(response_data == rhs.response_data))
    return false;
  return true;
}

Response::Response(const Response& other99) {
  results = other99.results;
  response_data = other99.response_data;
  __isset = other99.__isset;
}
Response& Response::operator=(const Response& other100) {
  results = other100.results;
  response_data = other100.response_data;
  __isset = other100.__isset;
  return *this;
}
void Response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Response(";
  out << "results=" << to_string(results);
  out << ", " << "response_data="; (__isset.response_data ? (out << to_string(response_data)) : (out << "<null>"));
  out << ")";
}


EnumDefinition::~EnumDefinition() noexcept {
}

EnumDefinition::EnumDefinition() noexcept
   : enum_name(),
     description() {
}

void EnumDefinition::__set_enum_name(const std::string& val) {
  this->enum_name = val;
}

void EnumDefinition::__set_values(const std::map<std::string, int32_t> & val) {
  this->values = val;
}

void EnumDefinition::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}
std::ostream& operator<<(std::ostream& out, const EnumDefinition& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnumDefinition::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->enum_name);
          this->__isset.enum_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->values.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _ktype102;
            ::apache::thrift::protocol::TType _vtype103;
            xfer += iprot->readMapBegin(_ktype102, _vtype103, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              std::string _key106;
              xfer += iprot->readString(_key106);
              int32_t& _val107 = this->values[_key106];
              xfer += iprot->readI32(_val107);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnumDefinition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnumDefinition");

  xfer += oprot->writeFieldBegin("enum_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->enum_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->values.size()));
    std::map<std::string, int32_t> ::const_iterator _iter108;
    for (_iter108 = this->values.begin(); _iter108 != this->values.end(); ++_iter108)
    {
      xfer += oprot->writeString(_iter108->first);
      xfer += oprot->writeI32(_iter108->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnumDefinition &a, EnumDefinition &b) noexcept {
  using ::std::swap;
  swap(a.enum_name, b.enum_name);
  swap(a.values, b.values);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

bool EnumDefinition::operator==(const EnumDefinition & rhs) const
{
  if (!(enum_name == rhs.enum_name))
    return false;
  if (!(values == rhs.values))
    return false;
  if (__isset.description != rhs.__isset.description)
    return false;
  else if (__isset.description && !(description == rhs.description))
    return false;
  return true;
}

EnumDefinition::EnumDefinition(const EnumDefinition& other109) {
  enum_name = other109.enum_name;
  values = other109.values;
  description = other109.description;
  __isset = other109.__isset;
}
EnumDefinition& EnumDefinition::operator=(const EnumDefinition& other110) {
  enum_name = other110.enum_name;
  values = other110.values;
  description = other110.description;
  __isset = other110.__isset;
  return *this;
}
void EnumDefinition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnumDefinition(";
  out << "enum_name=" << to_string(enum_name);
  out << ", " << "values=" << to_string(values);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


FieldEnumMapping::~FieldEnumMapping() noexcept {
}

FieldEnumMapping::FieldEnumMapping() noexcept
   : field_path(),
     enum_name() {
}

void FieldEnumMapping::__set_field_path(const std::string& val) {
  this->field_path = val;
}

void FieldEnumMapping::__set_enum_name(const std::string& val) {
  this->enum_name = val;
}
std::ostream& operator<<(std::ostream& out, const FieldEnumMapping& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FieldEnumMapping::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field_path);
          this->__isset.field_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->enum_name);
          this->__isset.enum_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FieldEnumMapping::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FieldEnumMapping");

  xfer += oprot->writeFieldBegin("field_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->field_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enum_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->enum_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FieldEnumMapping &a, FieldEnumMapping &b) noexcept {
  using ::std::swap;
  swap(a.field_path, b.field_path);
  swap(a.enum_name, b.enum_name);
  swap(a.__isset, b.__isset);
}

bool FieldEnumMapping::operator==(const FieldEnumMapping & rhs) const
{
  if (!(field_path == rhs.field_path))
    return false;
  if (!(enum_name == rhs.enum_name))
    return false;
  return true;
}

FieldEnumMapping::FieldEnumMapping(const FieldEnumMapping& other111) {
  field_path = other111.field_path;
  enum_name = other111.enum_name;
  __isset = other111.__isset;
}
FieldEnumMapping& FieldEnumMapping::operator=(const FieldEnumMapping& other112) {
  field_path = other112.field_path;
  enum_name = other112.enum_name;
  __isset = other112.__isset;
  return *this;
}
void FieldEnumMapping::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FieldEnumMapping(";
  out << "field_path=" << to_string(field_path);
  out << ", " << "enum_name=" << to_string(enum_name);
  out << ")";
}


MethodDescription::~MethodDescription() noexcept {
}

MethodDescription::MethodDescription() noexcept
   : method_name(),
     description(),
     example_request_json(),
     example_response_json() {
}

void MethodDescription::__set_method_name(const std::string& val) {
  this->method_name = val;
}

void MethodDescription::__set_description(const std::string& val) {
  this->description = val;
}

void MethodDescription::__set_example_request_json(const std::string& val) {
  this->example_request_json = val;
}

void MethodDescription::__set_example_response_json(const std::string& val) {
  this->example_response_json = val;
}

void MethodDescription::__set_request_enum_fields(const std::vector<FieldEnumMapping> & val) {
  this->request_enum_fields = val;
}

void MethodDescription::__set_response_enum_fields(const std::vector<FieldEnumMapping> & val) {
  this->response_enum_fields = val;
}
std::ostream& operator<<(std::ostream& out, const MethodDescription& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MethodDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method_name);
          this->__isset.method_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->example_request_json);
          this->__isset.example_request_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->example_response_json);
          this->__isset.example_response_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->request_enum_fields.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->request_enum_fields.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += this->request_enum_fields[_i117].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.request_enum_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->response_enum_fields.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->response_enum_fields.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += this->response_enum_fields[_i122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.response_enum_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MethodDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MethodDescription");

  xfer += oprot->writeFieldBegin("method_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("example_request_json", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->example_request_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("example_response_json", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->example_response_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request_enum_fields", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->request_enum_fields.size()));
    std::vector<FieldEnumMapping> ::const_iterator _iter123;
    for (_iter123 = this->request_enum_fields.begin(); _iter123 != this->request_enum_fields.end(); ++_iter123)
    {
      xfer += (*_iter123).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response_enum_fields", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->response_enum_fields.size()));
    std::vector<FieldEnumMapping> ::const_iterator _iter124;
    for (_iter124 = this->response_enum_fields.begin(); _iter124 != this->response_enum_fields.end(); ++_iter124)
    {
      xfer += (*_iter124).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MethodDescription &a, MethodDescription &b) noexcept {
  using ::std::swap;
  swap(a.method_name, b.method_name);
  swap(a.description, b.description);
  swap(a.example_request_json, b.example_request_json);
  swap(a.example_response_json, b.example_response_json);
  swap(a.request_enum_fields, b.request_enum_fields);
  swap(a.response_enum_fields, b.response_enum_fields);
  swap(a.__isset, b.__isset);
}

bool MethodDescription::operator==(const MethodDescription & rhs) const
{
  if (!(method_name == rhs.method_name))
    return false;
  if (!(description == rhs.description))
    return false;
  if (!(example_request_json == rhs.example_request_json))
    return false;
  if (!(example_response_json == rhs.example_response_json))
    return false;
  if (!(request_enum_fields == rhs.request_enum_fields))
    return false;
  if (!(response_enum_fields == rhs.response_enum_fields))
    return false;
  return true;
}

MethodDescription::MethodDescription(const MethodDescription& other125) {
  method_name = other125.method_name;
  description = other125.description;
  example_request_json = other125.example_request_json;
  example_response_json = other125.example_response_json;
  request_enum_fields = other125.request_enum_fields;
  response_enum_fields = other125.response_enum_fields;
  __isset = other125.__isset;
}
MethodDescription& MethodDescription::operator=(const MethodDescription& other126) {
  method_name = other126.method_name;
  description = other126.description;
  example_request_json = other126.example_request_json;
  example_response_json = other126.example_response_json;
  request_enum_fields = other126.request_enum_fields;
  response_enum_fields = other126.response_enum_fields;
  __isset = other126.__isset;
  return *this;
}
void MethodDescription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MethodDescription(";
  out << "method_name=" << to_string(method_name);
  out << ", " << "description=" << to_string(description);
  out << ", " << "example_request_json=" << to_string(example_request_json);
  out << ", " << "example_response_json=" << to_string(example_response_json);
  out << ", " << "request_enum_fields=" << to_string(request_enum_fields);
  out << ", " << "response_enum_fields=" << to_string(response_enum_fields);
  out << ")";
}


ServiceMetadata::~ServiceMetadata() noexcept {
}

ServiceMetadata::ServiceMetadata() noexcept
   : service_name(),
     version(),
     description() {
}

void ServiceMetadata::__set_service_name(const std::string& val) {
  this->service_name = val;
}

void ServiceMetadata::__set_version(const std::string& val) {
  this->version = val;
}

void ServiceMetadata::__set_description(const std::string& val) {
  this->description = val;
}

void ServiceMetadata::__set_methods(const std::vector<MethodDescription> & val) {
  this->methods = val;
}

void ServiceMetadata::__set_enums(const std::vector<EnumDefinition> & val) {
  this->enums = val;
}
std::ostream& operator<<(std::ostream& out, const ServiceMetadata& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ServiceMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->service_name);
          this->__isset.service_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->methods.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->methods.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += this->methods[_i131].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.methods = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->enums.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->enums.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += this->enums[_i136].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.enums = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServiceMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServiceMetadata");

  xfer += oprot->writeFieldBegin("service_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->service_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("methods", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->methods.size()));
    std::vector<MethodDescription> ::const_iterator _iter137;
    for (_iter137 = this->methods.begin(); _iter137 != this->methods.end(); ++_iter137)
    {
      xfer += (*_iter137).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enums", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->enums.size()));
    std::vector<EnumDefinition> ::const_iterator _iter138;
    for (_iter138 = this->enums.begin(); _iter138 != this->enums.end(); ++_iter138)
    {
      xfer += (*_iter138).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceMetadata &a, ServiceMetadata &b) noexcept {
  using ::std::swap;
  swap(a.service_name, b.service_name);
  swap(a.version, b.version);
  swap(a.description, b.description);
  swap(a.methods, b.methods);
  swap(a.enums, b.enums);
  swap(a.__isset, b.__isset);
}

bool ServiceMetadata::operator==(const ServiceMetadata & rhs) const
{
  if (!(service_name == rhs.service_name))
    return false;
  if (!(version == rhs.version))
    return false;
  if (!(description == rhs.description))
    return false;
  if (!(methods == rhs.methods))
    return false;
  if (!(enums == rhs.enums))
    return false;
  return true;
}

ServiceMetadata::ServiceMetadata(const ServiceMetadata& other139) {
  service_name = other139.service_name;
  version = other139.version;
  description = other139.description;
  methods = other139.methods;
  enums = other139.enums;
  __isset = other139.__isset;
}
ServiceMetadata& ServiceMetadata::operator=(const ServiceMetadata& other140) {
  service_name = other140.service_name;
  version = other140.version;
  description = other140.description;
  methods = other140.methods;
  enums = other140.enums;
  __isset = other140.__isset;
  return *this;
}
void ServiceMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServiceMetadata(";
  out << "service_name=" << to_string(service_name);
  out << ", " << "version=" << to_string(version);
  out << ", " << "description=" << to_string(description);
  out << ", " << "methods=" << to_string(methods);
  out << ", " << "enums=" << to_string(enums);
  out << ")";
}


