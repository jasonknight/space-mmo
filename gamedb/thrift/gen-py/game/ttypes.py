#
# Autogenerated by Thrift Compiler (0.23.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class ItemType(object):
    VIRTUAL = 1
    CONTAINER = 2
    WEAPON = 3
    RAWMATERIAL = 4
    REFINEDMATERIAL = 5

    _VALUES_TO_NAMES = {
        1: "VIRTUAL",
        2: "CONTAINER",
        3: "WEAPON",
        4: "RAWMATERIAL",
        5: "REFINEDMATERIAL",
    }

    _NAMES_TO_VALUES = {
        "VIRTUAL": 1,
        "CONTAINER": 2,
        "WEAPON": 3,
        "RAWMATERIAL": 4,
        "REFINEDMATERIAL": 5,
    }


class ItemAttributeType(object):
    TRANSLATED_NAME = 1
    TRANSLATED_SHORT_DESCRIPTION = 2
    TRANSLATED_LONG_DESCRIPTION = 3
    TRANSLATED_ASSET = 4
    UNTRANSLATED_ASSET = 5
    QUANTITY = 6
    GALACTIC_POSITION = 7
    SOLAR_POSITION = 8
    GLOBAL_POSITION = 9
    LOCAL_POSITION = 10
    SIZE = 11
    ITEM = 12
    PURITY = 13
    VOLUME = 14

    _VALUES_TO_NAMES = {
        1: "TRANSLATED_NAME",
        2: "TRANSLATED_SHORT_DESCRIPTION",
        3: "TRANSLATED_LONG_DESCRIPTION",
        4: "TRANSLATED_ASSET",
        5: "UNTRANSLATED_ASSET",
        6: "QUANTITY",
        7: "GALACTIC_POSITION",
        8: "SOLAR_POSITION",
        9: "GLOBAL_POSITION",
        10: "LOCAL_POSITION",
        11: "SIZE",
        12: "ITEM",
        13: "PURITY",
        14: "VOLUME",
    }

    _NAMES_TO_VALUES = {
        "TRANSLATED_NAME": 1,
        "TRANSLATED_SHORT_DESCRIPTION": 2,
        "TRANSLATED_LONG_DESCRIPTION": 3,
        "TRANSLATED_ASSET": 4,
        "UNTRANSLATED_ASSET": 5,
        "QUANTITY": 6,
        "GALACTIC_POSITION": 7,
        "SOLAR_POSITION": 8,
        "GLOBAL_POSITION": 9,
        "LOCAL_POSITION": 10,
        "SIZE": 11,
        "ITEM": 12,
        "PURITY": 13,
        "VOLUME": 14,
    }


class StatusType(object):
    SUCCESS = 1
    FAILURE = 2
    SKIP = 3

    _VALUES_TO_NAMES = {
        1: "SUCCESS",
        2: "FAILURE",
        3: "SKIP",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 1,
        "FAILURE": 2,
        "SKIP": 3,
    }


class NotApplicable(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotApplicable')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StackabilityInfo(object):
    """
    Attributes:
     - max_stack_size

    """
    thrift_spec = None


    def __init__(self, max_stack_size = None,):
        self.max_stack_size = max_stack_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.max_stack_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StackabilityInfo')
        if self.max_stack_size is not None:
            oprot.writeFieldBegin('max_stack_size', TType.I64, 1)
            oprot.writeI64(self.max_stack_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Stackability(object):
    """
    Attributes:
     - not_applicable
     - stackable

    """
    thrift_spec = None


    def __init__(self, not_applicable = None, stackable = None,):
        self.not_applicable = not_applicable
        self.stackable = stackable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.not_applicable = NotApplicable()
                    self.not_applicable.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.stackable = StackabilityInfo()
                    self.stackable.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Stackability')
        if self.not_applicable is not None:
            oprot.writeFieldBegin('not_applicable', TType.STRUCT, 1)
            self.not_applicable.write(oprot)
            oprot.writeFieldEnd()
        if self.stackable is not None:
            oprot.writeFieldBegin('stackable', TType.STRUCT, 2)
            self.stackable.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemVector3(object):
    """
    Attributes:
     - x
     - y
     - z

    """
    thrift_spec = None


    def __init__(self, x = None, y = None, z = None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemVector3')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemAttributeValue(object):
    """
    Attributes:
     - bool_value
     - double_value
     - vector3
     - asset_id

    """
    thrift_spec = None


    def __init__(self, bool_value = None, double_value = None, vector3 = None, asset_id = None,):
        self.bool_value = bool_value
        self.double_value = double_value
        self.vector3 = vector3
        self.asset_id = asset_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.bool_value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.double_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.vector3 = ItemVector3()
                    self.vector3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.asset_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemAttributeValue')
        if self.bool_value is not None:
            oprot.writeFieldBegin('bool_value', TType.BOOL, 1)
            oprot.writeBool(self.bool_value)
            oprot.writeFieldEnd()
        if self.double_value is not None:
            oprot.writeFieldBegin('double_value', TType.DOUBLE, 2)
            oprot.writeDouble(self.double_value)
            oprot.writeFieldEnd()
        if self.vector3 is not None:
            oprot.writeFieldBegin('vector3', TType.STRUCT, 3)
            self.vector3.write(oprot)
            oprot.writeFieldEnd()
        if self.asset_id is not None:
            oprot.writeFieldBegin('asset_id', TType.I64, 4)
            oprot.writeI64(self.asset_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemAttribute(object):
    """
    Attributes:
     - id
     - internal_name
     - visible
     - value
     - attribute_type

    """
    thrift_spec = None


    def __init__(self, id = None, internal_name = None, visible = None, value = None, attribute_type = None,):
        self.id = id
        self.internal_name = internal_name
        self.visible = visible
        self.value = value
        self.attribute_type = attribute_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.internal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.visible = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.value = ItemAttributeValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.attribute_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemAttribute')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.internal_name is not None:
            oprot.writeFieldBegin('internal_name', TType.STRING, 2)
            oprot.writeString(self.internal_name.encode('utf-8') if sys.version_info[0] == 2 else self.internal_name)
            oprot.writeFieldEnd()
        if self.visible is not None:
            oprot.writeFieldBegin('visible', TType.BOOL, 3)
            oprot.writeBool(self.visible)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 4)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.attribute_type is not None:
            oprot.writeFieldBegin('attribute_type', TType.I32, 5)
            oprot.writeI32(self.attribute_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Item(object):
    """
    Attributes:
     - id
     - internal_name
     - attributes
     - stackable
     - item_type
     - blueprint

    """
    thrift_spec = None


    def __init__(self, id = None, internal_name = None, attributes = None, stackable = None, item_type = None, blueprint = None,):
        self.id = id
        self.internal_name = internal_name
        self.attributes = attributes
        self.stackable = stackable
        self.item_type = item_type
        self.blueprint = blueprint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.internal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readI32()
                        _val6 = ItemAttribute()
                        _val6.read(iprot)
                        self.attributes[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.stackable = Stackability()
                    self.stackable.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.item_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.blueprint = ItemBlueprint()
                    self.blueprint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Item')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.internal_name is not None:
            oprot.writeFieldBegin('internal_name', TType.STRING, 2)
            oprot.writeString(self.internal_name.encode('utf-8') if sys.version_info[0] == 2 else self.internal_name)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.attributes))
            for kiter7, viter8 in self.attributes.items():
                oprot.writeI32(kiter7)
                viter8.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.stackable is not None:
            oprot.writeFieldBegin('stackable', TType.STRUCT, 4)
            self.stackable.write(oprot)
            oprot.writeFieldEnd()
        if self.item_type is not None:
            oprot.writeFieldBegin('item_type', TType.I32, 5)
            oprot.writeI32(self.item_type)
            oprot.writeFieldEnd()
        if self.blueprint is not None:
            oprot.writeFieldBegin('blueprint', TType.STRUCT, 6)
            self.blueprint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemBlueprintComponent(object):
    """
    Attributes:
     - ratio
     - item_id

    """
    thrift_spec = None


    def __init__(self, ratio = None, item_id = None,):
        self.ratio = ratio
        self.item_id = item_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemBlueprintComponent')
        if self.ratio is not None:
            oprot.writeFieldBegin('ratio', TType.DOUBLE, 1)
            oprot.writeDouble(self.ratio)
            oprot.writeFieldEnd()
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 2)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemBlueprint(object):
    """
    Attributes:
     - components
     - bake_time_ms

    """
    thrift_spec = None


    def __init__(self, components = None, bake_time_ms = None,):
        self.components = components
        self.bake_time_ms = bake_time_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.components = {}
                    (_ktype10, _vtype11, _size9) = iprot.readMapBegin()
                    for _i13 in range(_size9):
                        _key14 = iprot.readI64()
                        _val15 = ItemBlueprintComponent()
                        _val15.read(iprot)
                        self.components[_key14] = _val15
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.bake_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemBlueprint')
        if self.components is not None:
            oprot.writeFieldBegin('components', TType.MAP, 1)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.components))
            for kiter16, viter17 in self.components.items():
                oprot.writeI64(kiter16)
                viter17.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.bake_time_ms is not None:
            oprot.writeFieldBegin('bake_time_ms', TType.I64, 2)
            oprot.writeI64(self.bake_time_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemDb(object):
    """
    Attributes:
     - items

    """
    thrift_spec = None


    def __init__(self, items = None,):
        self.items = items

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.items = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = Item()
                        _elem23.read(iprot)
                        self.items.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemDb')
        if self.items is not None:
            oprot.writeFieldBegin('items', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.items))
            for iter24 in self.items:
                iter24.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InventoryEntry(object):
    """
    Attributes:
     - item_id
     - quantity
     - is_max_stacked

    """
    thrift_spec = None


    def __init__(self, item_id = None, quantity = None, is_max_stacked = False,):
        self.item_id = item_id
        self.quantity = quantity
        self.is_max_stacked = is_max_stacked

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.quantity = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_max_stacked = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InventoryEntry')
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 1)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        if self.quantity is not None:
            oprot.writeFieldBegin('quantity', TType.DOUBLE, 2)
            oprot.writeDouble(self.quantity)
            oprot.writeFieldEnd()
        if self.is_max_stacked is not None:
            oprot.writeFieldBegin('is_max_stacked', TType.BOOL, 3)
            oprot.writeBool(self.is_max_stacked)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Inventory(object):
    """
    Attributes:
     - id
     - max_entries
     - max_volume
     - entries
     - last_calculated_volume

    """
    thrift_spec = None


    def __init__(self, id = None, max_entries = None, max_volume = None, entries = None, last_calculated_volume = 0.0000000000000000,):
        self.id = id
        self.max_entries = max_entries
        self.max_volume = max_volume
        self.entries = entries
        self.last_calculated_volume = last_calculated_volume

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_entries = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.max_volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.entries = []
                    (_etype28, _size25) = iprot.readListBegin()
                    for _i29 in range(_size25):
                        _elem30 = InventoryEntry()
                        _elem30.read(iprot)
                        self.entries.append(_elem30)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.last_calculated_volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Inventory')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.max_entries is not None:
            oprot.writeFieldBegin('max_entries', TType.I64, 2)
            oprot.writeI64(self.max_entries)
            oprot.writeFieldEnd()
        if self.max_volume is not None:
            oprot.writeFieldBegin('max_volume', TType.DOUBLE, 3)
            oprot.writeDouble(self.max_volume)
            oprot.writeFieldEnd()
        if self.entries is not None:
            oprot.writeFieldBegin('entries', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.entries))
            for iter31 in self.entries:
                iter31.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.last_calculated_volume is not None:
            oprot.writeFieldBegin('last_calculated_volume', TType.DOUBLE, 5)
            oprot.writeDouble(self.last_calculated_volume)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InventoryResult(object):
    """
    Attributes:
     - status
     - message

    """
    thrift_spec = None


    def __init__(self, status = None, message = None,):
        self.status = status
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InventoryResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(NotApplicable)
NotApplicable.thrift_spec = (
)
all_structs.append(StackabilityInfo)
StackabilityInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'max_stack_size', None, None, ),  # 1
)
all_structs.append(Stackability)
Stackability.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'not_applicable', [NotApplicable, None], None, ),  # 1
    (2, TType.STRUCT, 'stackable', [StackabilityInfo, None], None, ),  # 2
)
all_structs.append(ItemVector3)
ItemVector3.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(ItemAttributeValue)
ItemAttributeValue.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'bool_value', None, None, ),  # 1
    (2, TType.DOUBLE, 'double_value', None, None, ),  # 2
    (3, TType.STRUCT, 'vector3', [ItemVector3, None], None, ),  # 3
    (4, TType.I64, 'asset_id', None, None, ),  # 4
)
all_structs.append(ItemAttribute)
ItemAttribute.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'internal_name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'visible', None, None, ),  # 3
    (4, TType.STRUCT, 'value', [ItemAttributeValue, None], None, ),  # 4
    (5, TType.I32, 'attribute_type', None, None, ),  # 5
)
all_structs.append(Item)
Item.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'internal_name', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.I32, None, TType.STRUCT, [ItemAttribute, None], False), None, ),  # 3
    (4, TType.STRUCT, 'stackable', [Stackability, None], None, ),  # 4
    (5, TType.I32, 'item_type', None, None, ),  # 5
    (6, TType.STRUCT, 'blueprint', [ItemBlueprint, None], None, ),  # 6
)
all_structs.append(ItemBlueprintComponent)
ItemBlueprintComponent.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'ratio', None, None, ),  # 1
    (2, TType.I64, 'item_id', None, None, ),  # 2
)
all_structs.append(ItemBlueprint)
ItemBlueprint.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'components', (TType.I64, None, TType.STRUCT, [ItemBlueprintComponent, None], False), None, ),  # 1
    (2, TType.I64, 'bake_time_ms', None, None, ),  # 2
)
all_structs.append(ItemDb)
ItemDb.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'items', (TType.STRUCT, [Item, None], False), None, ),  # 1
)
all_structs.append(InventoryEntry)
InventoryEntry.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'item_id', None, None, ),  # 1
    (2, TType.DOUBLE, 'quantity', None, None, ),  # 2
    (3, TType.BOOL, 'is_max_stacked', None, False, ),  # 3
)
all_structs.append(Inventory)
Inventory.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I64, 'max_entries', None, None, ),  # 2
    (3, TType.DOUBLE, 'max_volume', None, None, ),  # 3
    (4, TType.LIST, 'entries', (TType.STRUCT, [InventoryEntry, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'last_calculated_volume', None, 0.0000000000000000, ),  # 5
)
all_structs.append(InventoryResult)
InventoryResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
