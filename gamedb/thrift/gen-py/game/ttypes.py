#
# Autogenerated by Thrift Compiler (0.23.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class ItemType(object):
    VIRTUAL = 1
    CONTAINER = 2
    WEAPON = 3
    RAWMATERIAL = 4
    REFINEDMATERIAL = 5

    _VALUES_TO_NAMES = {
        1: "VIRTUAL",
        2: "CONTAINER",
        3: "WEAPON",
        4: "RAWMATERIAL",
        5: "REFINEDMATERIAL",
    }

    _NAMES_TO_VALUES = {
        "VIRTUAL": 1,
        "CONTAINER": 2,
        "WEAPON": 3,
        "RAWMATERIAL": 4,
        "REFINEDMATERIAL": 5,
    }


class MobileType(object):
    PLAYER = 1
    NPC = 2

    _VALUES_TO_NAMES = {
        1: "PLAYER",
        2: "NPC",
    }

    _NAMES_TO_VALUES = {
        "PLAYER": 1,
        "NPC": 2,
    }


class AttributeType(object):
    TRANSLATED_NAME = 1
    TRANSLATED_SHORT_DESCRIPTION = 2
    TRANSLATED_LONG_DESCRIPTION = 3
    TRANSLATED_ASSET = 4
    UNTRANSLATED_ASSET = 5
    QUANTITY = 6
    GALACTIC_POSITION = 7
    SOLAR_POSITION = 8
    GLOBAL_POSITION = 9
    LOCAL_POSITION = 10
    SIZE = 11
    ITEM = 12
    PURITY = 13
    VOLUME = 14

    _VALUES_TO_NAMES = {
        1: "TRANSLATED_NAME",
        2: "TRANSLATED_SHORT_DESCRIPTION",
        3: "TRANSLATED_LONG_DESCRIPTION",
        4: "TRANSLATED_ASSET",
        5: "UNTRANSLATED_ASSET",
        6: "QUANTITY",
        7: "GALACTIC_POSITION",
        8: "SOLAR_POSITION",
        9: "GLOBAL_POSITION",
        10: "LOCAL_POSITION",
        11: "SIZE",
        12: "ITEM",
        13: "PURITY",
        14: "VOLUME",
    }

    _NAMES_TO_VALUES = {
        "TRANSLATED_NAME": 1,
        "TRANSLATED_SHORT_DESCRIPTION": 2,
        "TRANSLATED_LONG_DESCRIPTION": 3,
        "TRANSLATED_ASSET": 4,
        "UNTRANSLATED_ASSET": 5,
        "QUANTITY": 6,
        "GALACTIC_POSITION": 7,
        "SOLAR_POSITION": 8,
        "GLOBAL_POSITION": 9,
        "LOCAL_POSITION": 10,
        "SIZE": 11,
        "ITEM": 12,
        "PURITY": 13,
        "VOLUME": 14,
    }


class StatusType(object):
    SUCCESS = 1
    FAILURE = 2
    SKIP = 3

    _VALUES_TO_NAMES = {
        1: "SUCCESS",
        2: "FAILURE",
        3: "SKIP",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 1,
        "FAILURE": 2,
        "SKIP": 3,
    }


class GameError(object):
    INV_MAX_ITEMS_REACHED = 1
    INV_ALL_ENTRIES_MAX_STACKED = 2
    INV_NEW_VOLUME_TOO_HIGH = 3
    INV_CANNOT_ADD_ITEM = 4
    INV_FAILED_TO_ADD = 5
    INV_FAILED_TO_TRANSFER = 6
    INV_COULD_NOT_FIND_ENTRY = 7
    INV_NEW_QUANTITY_INVALID = 8
    INV_FULL_CANNOT_SPLIT = 9
    INV_ITEM_NOT_FOUND = 10
    INV_INSUFFICIENT_QUANTITY = 11
    INV_OPERATION_FAILED = 22
    DB_CONNECTION_FAILED = 12
    DB_TRANSACTION_FAILED = 13
    DB_INSERT_FAILED = 14
    DB_UPDATE_FAILED = 15
    DB_DELETE_FAILED = 16
    DB_QUERY_FAILED = 17
    DB_RECORD_NOT_FOUND = 18
    DB_INVALID_DATA = 19
    DB_FOREIGN_KEY_VIOLATION = 20
    DB_UNIQUE_CONSTRAINT_VIOLATION = 21

    _VALUES_TO_NAMES = {
        1: "INV_MAX_ITEMS_REACHED",
        2: "INV_ALL_ENTRIES_MAX_STACKED",
        3: "INV_NEW_VOLUME_TOO_HIGH",
        4: "INV_CANNOT_ADD_ITEM",
        5: "INV_FAILED_TO_ADD",
        6: "INV_FAILED_TO_TRANSFER",
        7: "INV_COULD_NOT_FIND_ENTRY",
        8: "INV_NEW_QUANTITY_INVALID",
        9: "INV_FULL_CANNOT_SPLIT",
        10: "INV_ITEM_NOT_FOUND",
        11: "INV_INSUFFICIENT_QUANTITY",
        22: "INV_OPERATION_FAILED",
        12: "DB_CONNECTION_FAILED",
        13: "DB_TRANSACTION_FAILED",
        14: "DB_INSERT_FAILED",
        15: "DB_UPDATE_FAILED",
        16: "DB_DELETE_FAILED",
        17: "DB_QUERY_FAILED",
        18: "DB_RECORD_NOT_FOUND",
        19: "DB_INVALID_DATA",
        20: "DB_FOREIGN_KEY_VIOLATION",
        21: "DB_UNIQUE_CONSTRAINT_VIOLATION",
    }

    _NAMES_TO_VALUES = {
        "INV_MAX_ITEMS_REACHED": 1,
        "INV_ALL_ENTRIES_MAX_STACKED": 2,
        "INV_NEW_VOLUME_TOO_HIGH": 3,
        "INV_CANNOT_ADD_ITEM": 4,
        "INV_FAILED_TO_ADD": 5,
        "INV_FAILED_TO_TRANSFER": 6,
        "INV_COULD_NOT_FIND_ENTRY": 7,
        "INV_NEW_QUANTITY_INVALID": 8,
        "INV_FULL_CANNOT_SPLIT": 9,
        "INV_ITEM_NOT_FOUND": 10,
        "INV_INSUFFICIENT_QUANTITY": 11,
        "INV_OPERATION_FAILED": 22,
        "DB_CONNECTION_FAILED": 12,
        "DB_TRANSACTION_FAILED": 13,
        "DB_INSERT_FAILED": 14,
        "DB_UPDATE_FAILED": 15,
        "DB_DELETE_FAILED": 16,
        "DB_QUERY_FAILED": 17,
        "DB_RECORD_NOT_FOUND": 18,
        "DB_INVALID_DATA": 19,
        "DB_FOREIGN_KEY_VIOLATION": 20,
        "DB_UNIQUE_CONSTRAINT_VIOLATION": 21,
    }


class Owner(object):
    """
    Attributes:
     - mobile_id
     - item_it
     - asset_id

    """
    thrift_spec = None


    def __init__(self, mobile_id = None, item_it = None, asset_id = None,):
        self.mobile_id = mobile_id
        self.item_it = item_it
        self.asset_id = asset_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mobile_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.item_it = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.asset_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Owner')
        if self.mobile_id is not None:
            oprot.writeFieldBegin('mobile_id', TType.I64, 1)
            oprot.writeI64(self.mobile_id)
            oprot.writeFieldEnd()
        if self.item_it is not None:
            oprot.writeFieldBegin('item_it', TType.I64, 2)
            oprot.writeI64(self.item_it)
            oprot.writeFieldEnd()
        if self.asset_id is not None:
            oprot.writeFieldBegin('asset_id', TType.I64, 3)
            oprot.writeI64(self.asset_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemVector3(object):
    """
    Attributes:
     - x
     - y
     - z

    """
    thrift_spec = None


    def __init__(self, x = None, y = None, z = None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemVector3')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AttributeValue(object):
    """
    Attributes:
     - bool_value
     - double_value
     - vector3
     - asset_id

    """
    thrift_spec = None


    def __init__(self, bool_value = None, double_value = None, vector3 = None, asset_id = None,):
        self.bool_value = bool_value
        self.double_value = double_value
        self.vector3 = vector3
        self.asset_id = asset_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.bool_value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.double_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.vector3 = ItemVector3()
                    self.vector3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.asset_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AttributeValue')
        if self.bool_value is not None:
            oprot.writeFieldBegin('bool_value', TType.BOOL, 1)
            oprot.writeBool(self.bool_value)
            oprot.writeFieldEnd()
        if self.double_value is not None:
            oprot.writeFieldBegin('double_value', TType.DOUBLE, 2)
            oprot.writeDouble(self.double_value)
            oprot.writeFieldEnd()
        if self.vector3 is not None:
            oprot.writeFieldBegin('vector3', TType.STRUCT, 3)
            self.vector3.write(oprot)
            oprot.writeFieldEnd()
        if self.asset_id is not None:
            oprot.writeFieldBegin('asset_id', TType.I64, 4)
            oprot.writeI64(self.asset_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Attribute(object):
    """
    Attributes:
     - id
     - internal_name
     - visible
     - value
     - attribute_type
     - owner

    """
    thrift_spec = None


    def __init__(self, id = None, internal_name = None, visible = None, value = None, attribute_type = None, owner = None,):
        self.id = id
        self.internal_name = internal_name
        self.visible = visible
        self.value = value
        self.attribute_type = attribute_type
        self.owner = owner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.internal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.visible = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.value = AttributeValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.attribute_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.owner = Owner()
                    self.owner.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Attribute')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.internal_name is not None:
            oprot.writeFieldBegin('internal_name', TType.STRING, 2)
            oprot.writeString(self.internal_name.encode('utf-8') if sys.version_info[0] == 2 else self.internal_name)
            oprot.writeFieldEnd()
        if self.visible is not None:
            oprot.writeFieldBegin('visible', TType.BOOL, 3)
            oprot.writeBool(self.visible)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 4)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.attribute_type is not None:
            oprot.writeFieldBegin('attribute_type', TType.I32, 5)
            oprot.writeI32(self.attribute_type)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRUCT, 6)
            self.owner.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Item(object):
    """
    Attributes:
     - id
     - internal_name
     - attributes
     - max_stack_size
     - item_type
     - blueprint

    """
    thrift_spec = None


    def __init__(self, id = None, internal_name = None, attributes = None, max_stack_size = None, item_type = None, blueprint = None,):
        self.id = id
        self.internal_name = internal_name
        self.attributes = attributes
        self.max_stack_size = max_stack_size
        self.item_type = item_type
        self.blueprint = blueprint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.internal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readI32()
                        _val6 = Attribute()
                        _val6.read(iprot)
                        self.attributes[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.max_stack_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.item_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.blueprint = ItemBlueprint()
                    self.blueprint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Item')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.internal_name is not None:
            oprot.writeFieldBegin('internal_name', TType.STRING, 2)
            oprot.writeString(self.internal_name.encode('utf-8') if sys.version_info[0] == 2 else self.internal_name)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.attributes))
            for kiter7, viter8 in self.attributes.items():
                oprot.writeI32(kiter7)
                viter8.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.max_stack_size is not None:
            oprot.writeFieldBegin('max_stack_size', TType.I64, 4)
            oprot.writeI64(self.max_stack_size)
            oprot.writeFieldEnd()
        if self.item_type is not None:
            oprot.writeFieldBegin('item_type', TType.I32, 5)
            oprot.writeI32(self.item_type)
            oprot.writeFieldEnd()
        if self.blueprint is not None:
            oprot.writeFieldBegin('blueprint', TType.STRUCT, 6)
            self.blueprint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemBlueprintComponent(object):
    """
    Attributes:
     - ratio
     - item_id

    """
    thrift_spec = None


    def __init__(self, ratio = None, item_id = None,):
        self.ratio = ratio
        self.item_id = item_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemBlueprintComponent')
        if self.ratio is not None:
            oprot.writeFieldBegin('ratio', TType.DOUBLE, 1)
            oprot.writeDouble(self.ratio)
            oprot.writeFieldEnd()
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 2)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemBlueprint(object):
    """
    Attributes:
     - id
     - components
     - bake_time_ms

    """
    thrift_spec = None


    def __init__(self, id = None, components = None, bake_time_ms = None,):
        self.id = id
        self.components = components
        self.bake_time_ms = bake_time_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.components = {}
                    (_ktype10, _vtype11, _size9) = iprot.readMapBegin()
                    for _i13 in range(_size9):
                        _key14 = iprot.readI64()
                        _val15 = ItemBlueprintComponent()
                        _val15.read(iprot)
                        self.components[_key14] = _val15
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.bake_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemBlueprint')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.components is not None:
            oprot.writeFieldBegin('components', TType.MAP, 2)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.components))
            for kiter16, viter17 in self.components.items():
                oprot.writeI64(kiter16)
                viter17.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.bake_time_ms is not None:
            oprot.writeFieldBegin('bake_time_ms', TType.I64, 3)
            oprot.writeI64(self.bake_time_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemDb(object):
    """
    Attributes:
     - items

    """
    thrift_spec = None


    def __init__(self, items = None,):
        self.items = items

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.items = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = Item()
                        _elem23.read(iprot)
                        self.items.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemDb')
        if self.items is not None:
            oprot.writeFieldBegin('items', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.items))
            for iter24 in self.items:
                iter24.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InventoryEntry(object):
    """
    Attributes:
     - item_id
     - quantity
     - is_max_stacked

    """
    thrift_spec = None


    def __init__(self, item_id = None, quantity = None, is_max_stacked = False,):
        self.item_id = item_id
        self.quantity = quantity
        self.is_max_stacked = is_max_stacked

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.quantity = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_max_stacked = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InventoryEntry')
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 1)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        if self.quantity is not None:
            oprot.writeFieldBegin('quantity', TType.DOUBLE, 2)
            oprot.writeDouble(self.quantity)
            oprot.writeFieldEnd()
        if self.is_max_stacked is not None:
            oprot.writeFieldBegin('is_max_stacked', TType.BOOL, 3)
            oprot.writeBool(self.is_max_stacked)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Inventory(object):
    """
    Attributes:
     - id
     - max_entries
     - max_volume
     - entries
     - last_calculated_volume
     - owner

    """
    thrift_spec = None


    def __init__(self, id = None, max_entries = None, max_volume = None, entries = None, last_calculated_volume = 0.0000000000000000, owner = None,):
        self.id = id
        self.max_entries = max_entries
        self.max_volume = max_volume
        self.entries = entries
        self.last_calculated_volume = last_calculated_volume
        self.owner = owner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_entries = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.max_volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.entries = []
                    (_etype28, _size25) = iprot.readListBegin()
                    for _i29 in range(_size25):
                        _elem30 = InventoryEntry()
                        _elem30.read(iprot)
                        self.entries.append(_elem30)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.last_calculated_volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.owner = Owner()
                    self.owner.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Inventory')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.max_entries is not None:
            oprot.writeFieldBegin('max_entries', TType.I64, 2)
            oprot.writeI64(self.max_entries)
            oprot.writeFieldEnd()
        if self.max_volume is not None:
            oprot.writeFieldBegin('max_volume', TType.DOUBLE, 3)
            oprot.writeDouble(self.max_volume)
            oprot.writeFieldEnd()
        if self.entries is not None:
            oprot.writeFieldBegin('entries', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.entries))
            for iter31 in self.entries:
                iter31.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.last_calculated_volume is not None:
            oprot.writeFieldBegin('last_calculated_volume', TType.DOUBLE, 5)
            oprot.writeDouble(self.last_calculated_volume)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRUCT, 6)
            self.owner.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GameResult(object):
    """
    Attributes:
     - status
     - message
     - error_code

    """
    thrift_spec = None


    def __init__(self, status = None, message = None, error_code = None,):
        self.status = status
        self.message = message
        self.error_code = error_code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.error_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GameResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.error_code is not None:
            oprot.writeFieldBegin('error_code', TType.I32, 3)
            oprot.writeI32(self.error_code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Mobile(object):
    """
    Attributes:
     - id
     - mobile_type
     - attributes

    """
    thrift_spec = None


    def __init__(self, id = None, mobile_type = None, attributes = None,):
        self.id = id
        self.mobile_type = mobile_type
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mobile_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype33, _vtype34, _size32) = iprot.readMapBegin()
                    for _i36 in range(_size32):
                        _key37 = iprot.readI32()
                        _val38 = Attribute()
                        _val38.read(iprot)
                        self.attributes[_key37] = _val38
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Mobile')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.mobile_type is not None:
            oprot.writeFieldBegin('mobile_type', TType.I32, 2)
            oprot.writeI32(self.mobile_type)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.attributes))
            for kiter39, viter40 in self.attributes.items():
                oprot.writeI32(kiter39)
                viter40.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadInventoryRequestData(object):
    """
    Attributes:
     - inventory_id

    """
    thrift_spec = None


    def __init__(self, inventory_id = None,):
        self.inventory_id = inventory_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.inventory_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadInventoryRequestData')
        if self.inventory_id is not None:
            oprot.writeFieldBegin('inventory_id', TType.I64, 1)
            oprot.writeI64(self.inventory_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateInventoryRequestData(object):
    """
    Attributes:
     - inventory

    """
    thrift_spec = None


    def __init__(self, inventory = None,):
        self.inventory = inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.inventory = Inventory()
                    self.inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateInventoryRequestData')
        if self.inventory is not None:
            oprot.writeFieldBegin('inventory', TType.STRUCT, 1)
            self.inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SaveInventoryRequestData(object):
    """
    Attributes:
     - inventory

    """
    thrift_spec = None


    def __init__(self, inventory = None,):
        self.inventory = inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.inventory = Inventory()
                    self.inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveInventoryRequestData')
        if self.inventory is not None:
            oprot.writeFieldBegin('inventory', TType.STRUCT, 1)
            self.inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SplitStackRequestData(object):
    """
    Attributes:
     - inventory_id
     - item_id
     - quantity_to_split

    """
    thrift_spec = None


    def __init__(self, inventory_id = None, item_id = None, quantity_to_split = None,):
        self.inventory_id = inventory_id
        self.item_id = item_id
        self.quantity_to_split = quantity_to_split

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.inventory_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.quantity_to_split = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SplitStackRequestData')
        if self.inventory_id is not None:
            oprot.writeFieldBegin('inventory_id', TType.I64, 1)
            oprot.writeI64(self.inventory_id)
            oprot.writeFieldEnd()
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 2)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        if self.quantity_to_split is not None:
            oprot.writeFieldBegin('quantity_to_split', TType.DOUBLE, 3)
            oprot.writeDouble(self.quantity_to_split)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TransferItemRequestData(object):
    """
    Attributes:
     - source_inventory_id
     - destination_inventory_id
     - item_id
     - quantity

    """
    thrift_spec = None


    def __init__(self, source_inventory_id = None, destination_inventory_id = None, item_id = None, quantity = None,):
        self.source_inventory_id = source_inventory_id
        self.destination_inventory_id = destination_inventory_id
        self.item_id = item_id
        self.quantity = quantity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.source_inventory_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.destination_inventory_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.quantity = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransferItemRequestData')
        if self.source_inventory_id is not None:
            oprot.writeFieldBegin('source_inventory_id', TType.I64, 1)
            oprot.writeI64(self.source_inventory_id)
            oprot.writeFieldEnd()
        if self.destination_inventory_id is not None:
            oprot.writeFieldBegin('destination_inventory_id', TType.I64, 2)
            oprot.writeI64(self.destination_inventory_id)
            oprot.writeFieldEnd()
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 3)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        if self.quantity is not None:
            oprot.writeFieldBegin('quantity', TType.DOUBLE, 4)
            oprot.writeDouble(self.quantity)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadInventoryResponseData(object):
    """
    Attributes:
     - inventory

    """
    thrift_spec = None


    def __init__(self, inventory = None,):
        self.inventory = inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.inventory = Inventory()
                    self.inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadInventoryResponseData')
        if self.inventory is not None:
            oprot.writeFieldBegin('inventory', TType.STRUCT, 1)
            self.inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateInventoryResponseData(object):
    """
    Attributes:
     - inventory

    """
    thrift_spec = None


    def __init__(self, inventory = None,):
        self.inventory = inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.inventory = Inventory()
                    self.inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateInventoryResponseData')
        if self.inventory is not None:
            oprot.writeFieldBegin('inventory', TType.STRUCT, 1)
            self.inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SaveInventoryResponseData(object):
    """
    Attributes:
     - inventory

    """
    thrift_spec = None


    def __init__(self, inventory = None,):
        self.inventory = inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.inventory = Inventory()
                    self.inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SaveInventoryResponseData')
        if self.inventory is not None:
            oprot.writeFieldBegin('inventory', TType.STRUCT, 1)
            self.inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SplitStackResponseData(object):
    """
    Attributes:
     - inventory

    """
    thrift_spec = None


    def __init__(self, inventory = None,):
        self.inventory = inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.inventory = Inventory()
                    self.inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SplitStackResponseData')
        if self.inventory is not None:
            oprot.writeFieldBegin('inventory', TType.STRUCT, 1)
            self.inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TransferItemResponseData(object):
    """
    Attributes:
     - source_inventory
     - destination_inventory

    """
    thrift_spec = None


    def __init__(self, source_inventory = None, destination_inventory = None,):
        self.source_inventory = source_inventory
        self.destination_inventory = destination_inventory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.source_inventory = Inventory()
                    self.source_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.destination_inventory = Inventory()
                    self.destination_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransferItemResponseData')
        if self.source_inventory is not None:
            oprot.writeFieldBegin('source_inventory', TType.STRUCT, 1)
            self.source_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.destination_inventory is not None:
            oprot.writeFieldBegin('destination_inventory', TType.STRUCT, 2)
            self.destination_inventory.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RequestData(object):
    """
    Attributes:
     - load_inventory
     - create_inventory
     - save_inventory
     - split_stack
     - transfer_item

    """
    thrift_spec = None


    def __init__(self, load_inventory = None, create_inventory = None, save_inventory = None, split_stack = None, transfer_item = None,):
        self.load_inventory = load_inventory
        self.create_inventory = create_inventory
        self.save_inventory = save_inventory
        self.split_stack = split_stack
        self.transfer_item = transfer_item

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.load_inventory = LoadInventoryRequestData()
                    self.load_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.create_inventory = CreateInventoryRequestData()
                    self.create_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.save_inventory = SaveInventoryRequestData()
                    self.save_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.split_stack = SplitStackRequestData()
                    self.split_stack.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transfer_item = TransferItemRequestData()
                    self.transfer_item.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RequestData')
        if self.load_inventory is not None:
            oprot.writeFieldBegin('load_inventory', TType.STRUCT, 1)
            self.load_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.create_inventory is not None:
            oprot.writeFieldBegin('create_inventory', TType.STRUCT, 2)
            self.create_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.save_inventory is not None:
            oprot.writeFieldBegin('save_inventory', TType.STRUCT, 3)
            self.save_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.split_stack is not None:
            oprot.writeFieldBegin('split_stack', TType.STRUCT, 4)
            self.split_stack.write(oprot)
            oprot.writeFieldEnd()
        if self.transfer_item is not None:
            oprot.writeFieldBegin('transfer_item', TType.STRUCT, 5)
            self.transfer_item.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ResponseData(object):
    """
    Attributes:
     - load_inventory
     - create_inventory
     - save_inventory
     - split_stack
     - transfer_item

    """
    thrift_spec = None


    def __init__(self, load_inventory = None, create_inventory = None, save_inventory = None, split_stack = None, transfer_item = None,):
        self.load_inventory = load_inventory
        self.create_inventory = create_inventory
        self.save_inventory = save_inventory
        self.split_stack = split_stack
        self.transfer_item = transfer_item

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.load_inventory = LoadInventoryResponseData()
                    self.load_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.create_inventory = CreateInventoryResponseData()
                    self.create_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.save_inventory = SaveInventoryResponseData()
                    self.save_inventory.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.split_stack = SplitStackResponseData()
                    self.split_stack.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transfer_item = TransferItemResponseData()
                    self.transfer_item.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResponseData')
        if self.load_inventory is not None:
            oprot.writeFieldBegin('load_inventory', TType.STRUCT, 1)
            self.load_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.create_inventory is not None:
            oprot.writeFieldBegin('create_inventory', TType.STRUCT, 2)
            self.create_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.save_inventory is not None:
            oprot.writeFieldBegin('save_inventory', TType.STRUCT, 3)
            self.save_inventory.write(oprot)
            oprot.writeFieldEnd()
        if self.split_stack is not None:
            oprot.writeFieldBegin('split_stack', TType.STRUCT, 4)
            self.split_stack.write(oprot)
            oprot.writeFieldEnd()
        if self.transfer_item is not None:
            oprot.writeFieldBegin('transfer_item', TType.STRUCT, 5)
            self.transfer_item.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Request(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.data = RequestData()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Request')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRUCT, 1)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Response(object):
    """
    Attributes:
     - results
     - response_data

    """
    thrift_spec = None


    def __init__(self, results = None, response_data = None,):
        self.results = results
        self.response_data = response_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.results = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = GameResult()
                        _elem46.read(iprot)
                        self.results.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.response_data = ResponseData()
                    self.response_data.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Response')
        if self.results is not None:
            oprot.writeFieldBegin('results', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.results))
            for iter47 in self.results:
                iter47.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.response_data is not None:
            oprot.writeFieldBegin('response_data', TType.STRUCT, 2)
            self.response_data.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EnumDefinition(object):
    """
    Attributes:
     - enum_name
     - values
     - description

    """
    thrift_spec = None


    def __init__(self, enum_name = None, values = None, description = None,):
        self.enum_name = enum_name
        self.values = values
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.enum_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.values = {}
                    (_ktype49, _vtype50, _size48) = iprot.readMapBegin()
                    for _i52 in range(_size48):
                        _key53 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val54 = iprot.readI32()
                        self.values[_key53] = _val54
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EnumDefinition')
        if self.enum_name is not None:
            oprot.writeFieldBegin('enum_name', TType.STRING, 1)
            oprot.writeString(self.enum_name.encode('utf-8') if sys.version_info[0] == 2 else self.enum_name)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.values))
            for kiter55, viter56 in self.values.items():
                oprot.writeString(kiter55.encode('utf-8') if sys.version_info[0] == 2 else kiter55)
                oprot.writeI32(viter56)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 3)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FieldEnumMapping(object):
    """
    Attributes:
     - field_path
     - enum_name

    """
    thrift_spec = None


    def __init__(self, field_path = None, enum_name = None,):
        self.field_path = field_path
        self.enum_name = enum_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.field_path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.enum_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FieldEnumMapping')
        if self.field_path is not None:
            oprot.writeFieldBegin('field_path', TType.STRING, 1)
            oprot.writeString(self.field_path.encode('utf-8') if sys.version_info[0] == 2 else self.field_path)
            oprot.writeFieldEnd()
        if self.enum_name is not None:
            oprot.writeFieldBegin('enum_name', TType.STRING, 2)
            oprot.writeString(self.enum_name.encode('utf-8') if sys.version_info[0] == 2 else self.enum_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MethodDescription(object):
    """
    Attributes:
     - method_name
     - description
     - example_request_json
     - example_response_json
     - request_enum_fields
     - response_enum_fields

    """
    thrift_spec = None


    def __init__(self, method_name = None, description = None, example_request_json = None, example_response_json = None, request_enum_fields = None, response_enum_fields = None,):
        self.method_name = method_name
        self.description = description
        self.example_request_json = example_request_json
        self.example_response_json = example_response_json
        self.request_enum_fields = request_enum_fields
        self.response_enum_fields = response_enum_fields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.method_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.example_request_json = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.example_response_json = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.request_enum_fields = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = FieldEnumMapping()
                        _elem62.read(iprot)
                        self.request_enum_fields.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.response_enum_fields = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = FieldEnumMapping()
                        _elem68.read(iprot)
                        self.response_enum_fields.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MethodDescription')
        if self.method_name is not None:
            oprot.writeFieldBegin('method_name', TType.STRING, 1)
            oprot.writeString(self.method_name.encode('utf-8') if sys.version_info[0] == 2 else self.method_name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 2)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.example_request_json is not None:
            oprot.writeFieldBegin('example_request_json', TType.STRING, 3)
            oprot.writeString(self.example_request_json.encode('utf-8') if sys.version_info[0] == 2 else self.example_request_json)
            oprot.writeFieldEnd()
        if self.example_response_json is not None:
            oprot.writeFieldBegin('example_response_json', TType.STRING, 4)
            oprot.writeString(self.example_response_json.encode('utf-8') if sys.version_info[0] == 2 else self.example_response_json)
            oprot.writeFieldEnd()
        if self.request_enum_fields is not None:
            oprot.writeFieldBegin('request_enum_fields', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.request_enum_fields))
            for iter69 in self.request_enum_fields:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.response_enum_fields is not None:
            oprot.writeFieldBegin('response_enum_fields', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.response_enum_fields))
            for iter70 in self.response_enum_fields:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServiceMetadata(object):
    """
    Attributes:
     - service_name
     - version
     - description
     - methods
     - enums

    """
    thrift_spec = None


    def __init__(self, service_name = None, version = None, description = None, methods = None, enums = None,):
        self.service_name = service_name
        self.version = version
        self.description = description
        self.methods = methods
        self.enums = enums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.service_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.methods = []
                    (_etype74, _size71) = iprot.readListBegin()
                    for _i75 in range(_size71):
                        _elem76 = MethodDescription()
                        _elem76.read(iprot)
                        self.methods.append(_elem76)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.enums = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = EnumDefinition()
                        _elem82.read(iprot)
                        self.enums.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServiceMetadata')
        if self.service_name is not None:
            oprot.writeFieldBegin('service_name', TType.STRING, 1)
            oprot.writeString(self.service_name.encode('utf-8') if sys.version_info[0] == 2 else self.service_name)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 2)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 3)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.methods is not None:
            oprot.writeFieldBegin('methods', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.methods))
            for iter83 in self.methods:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.enums is not None:
            oprot.writeFieldBegin('enums', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.enums))
            for iter84 in self.enums:
                iter84.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Owner)
Owner.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mobile_id', None, None, ),  # 1
    (2, TType.I64, 'item_it', None, None, ),  # 2
    (3, TType.I64, 'asset_id', None, None, ),  # 3
)
all_structs.append(ItemVector3)
ItemVector3.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(AttributeValue)
AttributeValue.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'bool_value', None, None, ),  # 1
    (2, TType.DOUBLE, 'double_value', None, None, ),  # 2
    (3, TType.STRUCT, 'vector3', [ItemVector3, None], None, ),  # 3
    (4, TType.I64, 'asset_id', None, None, ),  # 4
)
all_structs.append(Attribute)
Attribute.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'internal_name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'visible', None, None, ),  # 3
    (4, TType.STRUCT, 'value', [AttributeValue, None], None, ),  # 4
    (5, TType.I32, 'attribute_type', None, None, ),  # 5
    (6, TType.STRUCT, 'owner', [Owner, None], None, ),  # 6
)
all_structs.append(Item)
Item.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'internal_name', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.I32, None, TType.STRUCT, [Attribute, None], False), None, ),  # 3
    (4, TType.I64, 'max_stack_size', None, None, ),  # 4
    (5, TType.I32, 'item_type', None, None, ),  # 5
    (6, TType.STRUCT, 'blueprint', [ItemBlueprint, None], None, ),  # 6
)
all_structs.append(ItemBlueprintComponent)
ItemBlueprintComponent.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'ratio', None, None, ),  # 1
    (2, TType.I64, 'item_id', None, None, ),  # 2
)
all_structs.append(ItemBlueprint)
ItemBlueprint.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.MAP, 'components', (TType.I64, None, TType.STRUCT, [ItemBlueprintComponent, None], False), None, ),  # 2
    (3, TType.I64, 'bake_time_ms', None, None, ),  # 3
)
all_structs.append(ItemDb)
ItemDb.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'items', (TType.STRUCT, [Item, None], False), None, ),  # 1
)
all_structs.append(InventoryEntry)
InventoryEntry.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'item_id', None, None, ),  # 1
    (2, TType.DOUBLE, 'quantity', None, None, ),  # 2
    (3, TType.BOOL, 'is_max_stacked', None, False, ),  # 3
)
all_structs.append(Inventory)
Inventory.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I64, 'max_entries', None, None, ),  # 2
    (3, TType.DOUBLE, 'max_volume', None, None, ),  # 3
    (4, TType.LIST, 'entries', (TType.STRUCT, [InventoryEntry, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'last_calculated_volume', None, 0.0000000000000000, ),  # 5
    (6, TType.STRUCT, 'owner', [Owner, None], None, ),  # 6
)
all_structs.append(GameResult)
GameResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I32, 'error_code', None, None, ),  # 3
)
all_structs.append(Mobile)
Mobile.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I32, 'mobile_type', None, None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.I32, None, TType.STRUCT, [Attribute, None], False), None, ),  # 3
)
all_structs.append(LoadInventoryRequestData)
LoadInventoryRequestData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'inventory_id', None, None, ),  # 1
)
all_structs.append(CreateInventoryRequestData)
CreateInventoryRequestData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'inventory', [Inventory, None], None, ),  # 1
)
all_structs.append(SaveInventoryRequestData)
SaveInventoryRequestData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'inventory', [Inventory, None], None, ),  # 1
)
all_structs.append(SplitStackRequestData)
SplitStackRequestData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'inventory_id', None, None, ),  # 1
    (2, TType.I64, 'item_id', None, None, ),  # 2
    (3, TType.DOUBLE, 'quantity_to_split', None, None, ),  # 3
)
all_structs.append(TransferItemRequestData)
TransferItemRequestData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'source_inventory_id', None, None, ),  # 1
    (2, TType.I64, 'destination_inventory_id', None, None, ),  # 2
    (3, TType.I64, 'item_id', None, None, ),  # 3
    (4, TType.DOUBLE, 'quantity', None, None, ),  # 4
)
all_structs.append(LoadInventoryResponseData)
LoadInventoryResponseData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'inventory', [Inventory, None], None, ),  # 1
)
all_structs.append(CreateInventoryResponseData)
CreateInventoryResponseData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'inventory', [Inventory, None], None, ),  # 1
)
all_structs.append(SaveInventoryResponseData)
SaveInventoryResponseData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'inventory', [Inventory, None], None, ),  # 1
)
all_structs.append(SplitStackResponseData)
SplitStackResponseData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'inventory', [Inventory, None], None, ),  # 1
)
all_structs.append(TransferItemResponseData)
TransferItemResponseData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'source_inventory', [Inventory, None], None, ),  # 1
    (2, TType.STRUCT, 'destination_inventory', [Inventory, None], None, ),  # 2
)
all_structs.append(RequestData)
RequestData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'load_inventory', [LoadInventoryRequestData, None], None, ),  # 1
    (2, TType.STRUCT, 'create_inventory', [CreateInventoryRequestData, None], None, ),  # 2
    (3, TType.STRUCT, 'save_inventory', [SaveInventoryRequestData, None], None, ),  # 3
    (4, TType.STRUCT, 'split_stack', [SplitStackRequestData, None], None, ),  # 4
    (5, TType.STRUCT, 'transfer_item', [TransferItemRequestData, None], None, ),  # 5
)
all_structs.append(ResponseData)
ResponseData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'load_inventory', [LoadInventoryResponseData, None], None, ),  # 1
    (2, TType.STRUCT, 'create_inventory', [CreateInventoryResponseData, None], None, ),  # 2
    (3, TType.STRUCT, 'save_inventory', [SaveInventoryResponseData, None], None, ),  # 3
    (4, TType.STRUCT, 'split_stack', [SplitStackResponseData, None], None, ),  # 4
    (5, TType.STRUCT, 'transfer_item', [TransferItemResponseData, None], None, ),  # 5
)
all_structs.append(Request)
Request.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'data', [RequestData, None], None, ),  # 1
)
all_structs.append(Response)
Response.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'results', (TType.STRUCT, [GameResult, None], False), None, ),  # 1
    (2, TType.STRUCT, 'response_data', [ResponseData, None], None, ),  # 2
)
all_structs.append(EnumDefinition)
EnumDefinition.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'enum_name', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'values', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 2
    (3, TType.STRING, 'description', 'UTF8', None, ),  # 3
)
all_structs.append(FieldEnumMapping)
FieldEnumMapping.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'field_path', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'enum_name', 'UTF8', None, ),  # 2
)
all_structs.append(MethodDescription)
MethodDescription.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'method_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'description', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'example_request_json', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'example_response_json', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'request_enum_fields', (TType.STRUCT, [FieldEnumMapping, None], False), None, ),  # 5
    (6, TType.LIST, 'response_enum_fields', (TType.STRUCT, [FieldEnumMapping, None], False), None, ),  # 6
)
all_structs.append(ServiceMetadata)
ServiceMetadata.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'service_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'version', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'description', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'methods', (TType.STRUCT, [MethodDescription, None], False), None, ),  # 4
    (5, TType.LIST, 'enums', (TType.STRUCT, [EnumDefinition, None], False), None, ),  # 5
)
fix_spec(all_structs)
del all_structs
