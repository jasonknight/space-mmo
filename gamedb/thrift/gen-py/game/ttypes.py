#
# Autogenerated by Thrift Compiler (0.23.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class ItemType(object):
    VIRTUAL = 1
    CONTAINER = 2
    WEAPON = 3
    RAWMATERIAL = 4
    REFINEDMATERIAL = 5

    _VALUES_TO_NAMES = {
        1: "VIRTUAL",
        2: "CONTAINER",
        3: "WEAPON",
        4: "RAWMATERIAL",
        5: "REFINEDMATERIAL",
    }

    _NAMES_TO_VALUES = {
        "VIRTUAL": 1,
        "CONTAINER": 2,
        "WEAPON": 3,
        "RAWMATERIAL": 4,
        "REFINEDMATERIAL": 5,
    }


class MobileType(object):
    PLAYER = 1
    NPC = 2

    _VALUES_TO_NAMES = {
        1: "PLAYER",
        2: "NPC",
    }

    _NAMES_TO_VALUES = {
        "PLAYER": 1,
        "NPC": 2,
    }


class AttributeType(object):
    TRANSLATED_NAME = 1
    TRANSLATED_SHORT_DESCRIPTION = 2
    TRANSLATED_LONG_DESCRIPTION = 3
    TRANSLATED_ASSET = 4
    UNTRANSLATED_ASSET = 5
    QUANTITY = 6
    GALACTIC_POSITION = 7
    SOLAR_POSITION = 8
    GLOBAL_POSITION = 9
    LOCAL_POSITION = 10
    SIZE = 11
    ITEM = 12
    PURITY = 13
    VOLUME = 14

    _VALUES_TO_NAMES = {
        1: "TRANSLATED_NAME",
        2: "TRANSLATED_SHORT_DESCRIPTION",
        3: "TRANSLATED_LONG_DESCRIPTION",
        4: "TRANSLATED_ASSET",
        5: "UNTRANSLATED_ASSET",
        6: "QUANTITY",
        7: "GALACTIC_POSITION",
        8: "SOLAR_POSITION",
        9: "GLOBAL_POSITION",
        10: "LOCAL_POSITION",
        11: "SIZE",
        12: "ITEM",
        13: "PURITY",
        14: "VOLUME",
    }

    _NAMES_TO_VALUES = {
        "TRANSLATED_NAME": 1,
        "TRANSLATED_SHORT_DESCRIPTION": 2,
        "TRANSLATED_LONG_DESCRIPTION": 3,
        "TRANSLATED_ASSET": 4,
        "UNTRANSLATED_ASSET": 5,
        "QUANTITY": 6,
        "GALACTIC_POSITION": 7,
        "SOLAR_POSITION": 8,
        "GLOBAL_POSITION": 9,
        "LOCAL_POSITION": 10,
        "SIZE": 11,
        "ITEM": 12,
        "PURITY": 13,
        "VOLUME": 14,
    }


class StatusType(object):
    SUCCESS = 1
    FAILURE = 2
    SKIP = 3

    _VALUES_TO_NAMES = {
        1: "SUCCESS",
        2: "FAILURE",
        3: "SKIP",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 1,
        "FAILURE": 2,
        "SKIP": 3,
    }


class GameError(object):
    INV_MAX_ITEMS_REACHED = 1
    INV_ALL_ENTRIES_MAX_STACKED = 2
    INV_NEW_VOLUME_TOO_HIGH = 3
    INV_CANNOT_ADD_ITEM = 4
    INV_FAILED_TO_ADD = 5
    INV_FAILED_TO_TRANSFER = 6
    INV_COULD_NOT_FIND_ENTRY = 7
    INV_NEW_QUANTITY_INVALID = 8
    INV_FULL_CANNOT_SPLIT = 9
    INV_ITEM_NOT_FOUND = 10
    INV_INSUFFICIENT_QUANTITY = 11
    DB_CONNECTION_FAILED = 12
    DB_TRANSACTION_FAILED = 13
    DB_INSERT_FAILED = 14
    DB_UPDATE_FAILED = 15
    DB_DELETE_FAILED = 16
    DB_QUERY_FAILED = 17
    DB_RECORD_NOT_FOUND = 18
    DB_INVALID_DATA = 19
    DB_FOREIGN_KEY_VIOLATION = 20
    DB_UNIQUE_CONSTRAINT_VIOLATION = 21

    _VALUES_TO_NAMES = {
        1: "INV_MAX_ITEMS_REACHED",
        2: "INV_ALL_ENTRIES_MAX_STACKED",
        3: "INV_NEW_VOLUME_TOO_HIGH",
        4: "INV_CANNOT_ADD_ITEM",
        5: "INV_FAILED_TO_ADD",
        6: "INV_FAILED_TO_TRANSFER",
        7: "INV_COULD_NOT_FIND_ENTRY",
        8: "INV_NEW_QUANTITY_INVALID",
        9: "INV_FULL_CANNOT_SPLIT",
        10: "INV_ITEM_NOT_FOUND",
        11: "INV_INSUFFICIENT_QUANTITY",
        12: "DB_CONNECTION_FAILED",
        13: "DB_TRANSACTION_FAILED",
        14: "DB_INSERT_FAILED",
        15: "DB_UPDATE_FAILED",
        16: "DB_DELETE_FAILED",
        17: "DB_QUERY_FAILED",
        18: "DB_RECORD_NOT_FOUND",
        19: "DB_INVALID_DATA",
        20: "DB_FOREIGN_KEY_VIOLATION",
        21: "DB_UNIQUE_CONSTRAINT_VIOLATION",
    }

    _NAMES_TO_VALUES = {
        "INV_MAX_ITEMS_REACHED": 1,
        "INV_ALL_ENTRIES_MAX_STACKED": 2,
        "INV_NEW_VOLUME_TOO_HIGH": 3,
        "INV_CANNOT_ADD_ITEM": 4,
        "INV_FAILED_TO_ADD": 5,
        "INV_FAILED_TO_TRANSFER": 6,
        "INV_COULD_NOT_FIND_ENTRY": 7,
        "INV_NEW_QUANTITY_INVALID": 8,
        "INV_FULL_CANNOT_SPLIT": 9,
        "INV_ITEM_NOT_FOUND": 10,
        "INV_INSUFFICIENT_QUANTITY": 11,
        "DB_CONNECTION_FAILED": 12,
        "DB_TRANSACTION_FAILED": 13,
        "DB_INSERT_FAILED": 14,
        "DB_UPDATE_FAILED": 15,
        "DB_DELETE_FAILED": 16,
        "DB_QUERY_FAILED": 17,
        "DB_RECORD_NOT_FOUND": 18,
        "DB_INVALID_DATA": 19,
        "DB_FOREIGN_KEY_VIOLATION": 20,
        "DB_UNIQUE_CONSTRAINT_VIOLATION": 21,
    }


class Owner(object):
    """
    Attributes:
     - mobile_id
     - item_it
     - asset_id

    """
    thrift_spec = None


    def __init__(self, mobile_id = None, item_it = None, asset_id = None,):
        self.mobile_id = mobile_id
        self.item_it = item_it
        self.asset_id = asset_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mobile_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.item_it = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.asset_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Owner')
        if self.mobile_id is not None:
            oprot.writeFieldBegin('mobile_id', TType.I64, 1)
            oprot.writeI64(self.mobile_id)
            oprot.writeFieldEnd()
        if self.item_it is not None:
            oprot.writeFieldBegin('item_it', TType.I64, 2)
            oprot.writeI64(self.item_it)
            oprot.writeFieldEnd()
        if self.asset_id is not None:
            oprot.writeFieldBegin('asset_id', TType.I64, 3)
            oprot.writeI64(self.asset_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemVector3(object):
    """
    Attributes:
     - x
     - y
     - z

    """
    thrift_spec = None


    def __init__(self, x = None, y = None, z = None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemVector3')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AttributeValue(object):
    """
    Attributes:
     - bool_value
     - double_value
     - vector3
     - asset_id

    """
    thrift_spec = None


    def __init__(self, bool_value = None, double_value = None, vector3 = None, asset_id = None,):
        self.bool_value = bool_value
        self.double_value = double_value
        self.vector3 = vector3
        self.asset_id = asset_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.bool_value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.double_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.vector3 = ItemVector3()
                    self.vector3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.asset_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AttributeValue')
        if self.bool_value is not None:
            oprot.writeFieldBegin('bool_value', TType.BOOL, 1)
            oprot.writeBool(self.bool_value)
            oprot.writeFieldEnd()
        if self.double_value is not None:
            oprot.writeFieldBegin('double_value', TType.DOUBLE, 2)
            oprot.writeDouble(self.double_value)
            oprot.writeFieldEnd()
        if self.vector3 is not None:
            oprot.writeFieldBegin('vector3', TType.STRUCT, 3)
            self.vector3.write(oprot)
            oprot.writeFieldEnd()
        if self.asset_id is not None:
            oprot.writeFieldBegin('asset_id', TType.I64, 4)
            oprot.writeI64(self.asset_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Attribute(object):
    """
    Attributes:
     - id
     - internal_name
     - visible
     - value
     - attribute_type
     - owner

    """
    thrift_spec = None


    def __init__(self, id = None, internal_name = None, visible = None, value = None, attribute_type = None, owner = None,):
        self.id = id
        self.internal_name = internal_name
        self.visible = visible
        self.value = value
        self.attribute_type = attribute_type
        self.owner = owner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.internal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.visible = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.value = AttributeValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.attribute_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.owner = Owner()
                    self.owner.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Attribute')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.internal_name is not None:
            oprot.writeFieldBegin('internal_name', TType.STRING, 2)
            oprot.writeString(self.internal_name.encode('utf-8') if sys.version_info[0] == 2 else self.internal_name)
            oprot.writeFieldEnd()
        if self.visible is not None:
            oprot.writeFieldBegin('visible', TType.BOOL, 3)
            oprot.writeBool(self.visible)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 4)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.attribute_type is not None:
            oprot.writeFieldBegin('attribute_type', TType.I32, 5)
            oprot.writeI32(self.attribute_type)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRUCT, 6)
            self.owner.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Item(object):
    """
    Attributes:
     - id
     - internal_name
     - attributes
     - max_stack_size
     - item_type
     - blueprint

    """
    thrift_spec = None


    def __init__(self, id = None, internal_name = None, attributes = None, max_stack_size = None, item_type = None, blueprint = None,):
        self.id = id
        self.internal_name = internal_name
        self.attributes = attributes
        self.max_stack_size = max_stack_size
        self.item_type = item_type
        self.blueprint = blueprint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.internal_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readI32()
                        _val6 = Attribute()
                        _val6.read(iprot)
                        self.attributes[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.max_stack_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.item_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.blueprint = ItemBlueprint()
                    self.blueprint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Item')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.internal_name is not None:
            oprot.writeFieldBegin('internal_name', TType.STRING, 2)
            oprot.writeString(self.internal_name.encode('utf-8') if sys.version_info[0] == 2 else self.internal_name)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.attributes))
            for kiter7, viter8 in self.attributes.items():
                oprot.writeI32(kiter7)
                viter8.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.max_stack_size is not None:
            oprot.writeFieldBegin('max_stack_size', TType.I64, 4)
            oprot.writeI64(self.max_stack_size)
            oprot.writeFieldEnd()
        if self.item_type is not None:
            oprot.writeFieldBegin('item_type', TType.I32, 5)
            oprot.writeI32(self.item_type)
            oprot.writeFieldEnd()
        if self.blueprint is not None:
            oprot.writeFieldBegin('blueprint', TType.STRUCT, 6)
            self.blueprint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemBlueprintComponent(object):
    """
    Attributes:
     - ratio
     - item_id

    """
    thrift_spec = None


    def __init__(self, ratio = None, item_id = None,):
        self.ratio = ratio
        self.item_id = item_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemBlueprintComponent')
        if self.ratio is not None:
            oprot.writeFieldBegin('ratio', TType.DOUBLE, 1)
            oprot.writeDouble(self.ratio)
            oprot.writeFieldEnd()
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 2)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemBlueprint(object):
    """
    Attributes:
     - id
     - components
     - bake_time_ms

    """
    thrift_spec = None


    def __init__(self, id = None, components = None, bake_time_ms = None,):
        self.id = id
        self.components = components
        self.bake_time_ms = bake_time_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.components = {}
                    (_ktype10, _vtype11, _size9) = iprot.readMapBegin()
                    for _i13 in range(_size9):
                        _key14 = iprot.readI64()
                        _val15 = ItemBlueprintComponent()
                        _val15.read(iprot)
                        self.components[_key14] = _val15
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.bake_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemBlueprint')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.components is not None:
            oprot.writeFieldBegin('components', TType.MAP, 2)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.components))
            for kiter16, viter17 in self.components.items():
                oprot.writeI64(kiter16)
                viter17.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.bake_time_ms is not None:
            oprot.writeFieldBegin('bake_time_ms', TType.I64, 3)
            oprot.writeI64(self.bake_time_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ItemDb(object):
    """
    Attributes:
     - items

    """
    thrift_spec = None


    def __init__(self, items = None,):
        self.items = items

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.items = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = Item()
                        _elem23.read(iprot)
                        self.items.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ItemDb')
        if self.items is not None:
            oprot.writeFieldBegin('items', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.items))
            for iter24 in self.items:
                iter24.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InventoryEntry(object):
    """
    Attributes:
     - item_id
     - quantity
     - is_max_stacked

    """
    thrift_spec = None


    def __init__(self, item_id = None, quantity = None, is_max_stacked = False,):
        self.item_id = item_id
        self.quantity = quantity
        self.is_max_stacked = is_max_stacked

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.item_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.quantity = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_max_stacked = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InventoryEntry')
        if self.item_id is not None:
            oprot.writeFieldBegin('item_id', TType.I64, 1)
            oprot.writeI64(self.item_id)
            oprot.writeFieldEnd()
        if self.quantity is not None:
            oprot.writeFieldBegin('quantity', TType.DOUBLE, 2)
            oprot.writeDouble(self.quantity)
            oprot.writeFieldEnd()
        if self.is_max_stacked is not None:
            oprot.writeFieldBegin('is_max_stacked', TType.BOOL, 3)
            oprot.writeBool(self.is_max_stacked)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Inventory(object):
    """
    Attributes:
     - id
     - max_entries
     - max_volume
     - entries
     - last_calculated_volume
     - owner

    """
    thrift_spec = None


    def __init__(self, id = None, max_entries = None, max_volume = None, entries = None, last_calculated_volume = 0.0000000000000000, owner = None,):
        self.id = id
        self.max_entries = max_entries
        self.max_volume = max_volume
        self.entries = entries
        self.last_calculated_volume = last_calculated_volume
        self.owner = owner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_entries = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.max_volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.entries = []
                    (_etype28, _size25) = iprot.readListBegin()
                    for _i29 in range(_size25):
                        _elem30 = InventoryEntry()
                        _elem30.read(iprot)
                        self.entries.append(_elem30)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.last_calculated_volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.owner = Owner()
                    self.owner.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Inventory')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.max_entries is not None:
            oprot.writeFieldBegin('max_entries', TType.I64, 2)
            oprot.writeI64(self.max_entries)
            oprot.writeFieldEnd()
        if self.max_volume is not None:
            oprot.writeFieldBegin('max_volume', TType.DOUBLE, 3)
            oprot.writeDouble(self.max_volume)
            oprot.writeFieldEnd()
        if self.entries is not None:
            oprot.writeFieldBegin('entries', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.entries))
            for iter31 in self.entries:
                iter31.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.last_calculated_volume is not None:
            oprot.writeFieldBegin('last_calculated_volume', TType.DOUBLE, 5)
            oprot.writeDouble(self.last_calculated_volume)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRUCT, 6)
            self.owner.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GameResult(object):
    """
    Attributes:
     - status
     - message
     - error_code

    """
    thrift_spec = None


    def __init__(self, status = None, message = None, error_code = None,):
        self.status = status
        self.message = message
        self.error_code = error_code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.error_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GameResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.error_code is not None:
            oprot.writeFieldBegin('error_code', TType.I32, 3)
            oprot.writeI32(self.error_code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Mobile(object):
    """
    Attributes:
     - id
     - mobile_type
     - attributes

    """
    thrift_spec = None


    def __init__(self, id = None, mobile_type = None, attributes = None,):
        self.id = id
        self.mobile_type = mobile_type
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mobile_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype33, _vtype34, _size32) = iprot.readMapBegin()
                    for _i36 in range(_size32):
                        _key37 = iprot.readI32()
                        _val38 = Attribute()
                        _val38.read(iprot)
                        self.attributes[_key37] = _val38
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Mobile')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.mobile_type is not None:
            oprot.writeFieldBegin('mobile_type', TType.I32, 2)
            oprot.writeI32(self.mobile_type)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.attributes))
            for kiter39, viter40 in self.attributes.items():
                oprot.writeI32(kiter39)
                viter40.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Owner)
Owner.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mobile_id', None, None, ),  # 1
    (2, TType.I64, 'item_it', None, None, ),  # 2
    (3, TType.I64, 'asset_id', None, None, ),  # 3
)
all_structs.append(ItemVector3)
ItemVector3.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(AttributeValue)
AttributeValue.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'bool_value', None, None, ),  # 1
    (2, TType.DOUBLE, 'double_value', None, None, ),  # 2
    (3, TType.STRUCT, 'vector3', [ItemVector3, None], None, ),  # 3
    (4, TType.I64, 'asset_id', None, None, ),  # 4
)
all_structs.append(Attribute)
Attribute.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'internal_name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'visible', None, None, ),  # 3
    (4, TType.STRUCT, 'value', [AttributeValue, None], None, ),  # 4
    (5, TType.I32, 'attribute_type', None, None, ),  # 5
    (6, TType.STRUCT, 'owner', [Owner, None], None, ),  # 6
)
all_structs.append(Item)
Item.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'internal_name', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.I32, None, TType.STRUCT, [Attribute, None], False), None, ),  # 3
    (4, TType.I64, 'max_stack_size', None, None, ),  # 4
    (5, TType.I32, 'item_type', None, None, ),  # 5
    (6, TType.STRUCT, 'blueprint', [ItemBlueprint, None], None, ),  # 6
)
all_structs.append(ItemBlueprintComponent)
ItemBlueprintComponent.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'ratio', None, None, ),  # 1
    (2, TType.I64, 'item_id', None, None, ),  # 2
)
all_structs.append(ItemBlueprint)
ItemBlueprint.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.MAP, 'components', (TType.I64, None, TType.STRUCT, [ItemBlueprintComponent, None], False), None, ),  # 2
    (3, TType.I64, 'bake_time_ms', None, None, ),  # 3
)
all_structs.append(ItemDb)
ItemDb.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'items', (TType.STRUCT, [Item, None], False), None, ),  # 1
)
all_structs.append(InventoryEntry)
InventoryEntry.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'item_id', None, None, ),  # 1
    (2, TType.DOUBLE, 'quantity', None, None, ),  # 2
    (3, TType.BOOL, 'is_max_stacked', None, False, ),  # 3
)
all_structs.append(Inventory)
Inventory.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I64, 'max_entries', None, None, ),  # 2
    (3, TType.DOUBLE, 'max_volume', None, None, ),  # 3
    (4, TType.LIST, 'entries', (TType.STRUCT, [InventoryEntry, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'last_calculated_volume', None, 0.0000000000000000, ),  # 5
    (6, TType.STRUCT, 'owner', [Owner, None], None, ),  # 6
)
all_structs.append(GameResult)
GameResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I32, 'error_code', None, None, ),  # 3
)
all_structs.append(Mobile)
Mobile.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I32, 'mobile_type', None, None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.I32, None, TType.STRUCT, [Attribute, None], False), None, ),  # 3
)
fix_spec(all_structs)
del all_structs
