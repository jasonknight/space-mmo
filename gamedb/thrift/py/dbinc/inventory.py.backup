"""Inventory database operations."""

import sys
from typing import Optional, Tuple
import logging

sys.path.append("../../gen-py")

from game.ttypes import (
    GameResult,
    StatusType,
    GameError,
    Inventory,
    InventoryEntry,
)

# Configure logging
logger = logging.getLogger(__name__)


class InventoryMixin:
    """Mixin class for Inventory database operations."""

    def get_inventories_table_sql(
        self,
        database: str,
    ) -> list[str]:
        return [
            f"CREATE DATABASE IF NOT EXISTS {database};",
            f"""CREATE TABLE IF NOT EXISTS {database}.inventories (
                id BIGINT AUTO_INCREMENT PRIMARY KEY,
                owner_id BIGINT NOT NULL,
                owner_type VARCHAR(50),
                max_entries BIGINT NOT NULL,
                max_volume DOUBLE NOT NULL,
                last_calculated_volume DOUBLE DEFAULT 0.0
            );""",
        ]

    def get_inventory_entries_table_sql(
        self,
        database: str,
    ) -> list[str]:
        return [
            f"CREATE DATABASE IF NOT EXISTS {database};",
            f"""CREATE TABLE IF NOT EXISTS {database}.inventory_entries (
                id BIGINT AUTO_INCREMENT PRIMARY KEY,
                inventory_id BIGINT NOT NULL,
                item_id BIGINT NOT NULL,
                quantity DOUBLE NOT NULL,
                is_max_stacked BOOLEAN DEFAULT FALSE,
                FOREIGN KEY (inventory_id) REFERENCES {database}.inventories(id)
            );""",
        ]

    def get_inventory_owners_table_sql(
        self,
        database: str,
    ) -> list[str]:
        return [
            f"CREATE DATABASE IF NOT EXISTS {database};",
            f"""CREATE TABLE IF NOT EXISTS {database}.inventory_owners (
                id BIGINT AUTO_INCREMENT PRIMARY KEY,
                inventory_id BIGINT NOT NULL,
                mobile_id BIGINT,
                item_id BIGINT,
                asset_id BIGINT,
                player_id BIGINT,
                FOREIGN KEY (inventory_id) REFERENCES {database}.inventories(id)
            );""",
        ]

    def get_inventory_sql(
        self,
        database: str,
        obj: Inventory,
        table: Optional[str] = None,
        drop: bool = False,
        truncate: bool = False,
    ) -> list[str]:
        # If both drop and truncate are True, set truncate to False
        if drop and truncate:
            truncate = False

        inventory_table = table if table else "inventories"
        inventory_entries_table = "inventory_entries"
        inventory_owners_table = "inventory_owners"

        statements = []

        if drop:
            statements.append(
                f"DROP TABLE IF EXISTS {database}.{inventory_entries_table};"
            )
            statements.append(
                f"DROP TABLE IF EXISTS {database}.{inventory_owners_table};"
            )
            statements.append(f"DROP TABLE IF EXISTS {database}.{inventory_table};")

        if truncate:
            statements.append(f"TRUNCATE TABLE {database}.{inventory_entries_table};")
            statements.append(f"TRUNCATE TABLE {database}.{inventory_owners_table};")
            statements.append(f"TRUNCATE TABLE {database}.{inventory_table};")

        # Extract owner information
        from game.ttypes import Owner

        mobile_id = "NULL"
        item_id = "NULL"
        asset_id = "NULL"
        player_id = "NULL"
        owner_type = "NULL"
        owner_id = "NULL"

        if obj.owner is not None:
            # Thrift unions store the value directly as the union's value
            if isinstance(obj.owner, Owner):
                # It's an Owner object, check which field is set
                if hasattr(obj.owner, "mobile_id") and obj.owner.mobile_id is not None:
                    mobile_id = str(obj.owner.mobile_id)
                    owner_id = mobile_id
                    owner_type = "'MOBILE'"
                elif hasattr(obj.owner, "item_id") and obj.owner.item_id is not None:
                    item_id = str(obj.owner.item_id)
                    owner_id = item_id
                    owner_type = "'ITEM'"
                elif hasattr(obj.owner, "asset_id") and obj.owner.asset_id is not None:
                    asset_id = str(obj.owner.asset_id)
                    owner_id = asset_id
                    owner_type = "'ASSET'"
                elif (
                    hasattr(obj.owner, "player_id") and obj.owner.player_id is not None
                ):
                    player_id = str(obj.owner.player_id)
                    owner_id = player_id
                    owner_type = "'PLAYER'"
            elif isinstance(obj.owner, int):
                # It's a plain int, assume it's a mobile_id for backwards compatibility
                mobile_id = str(obj.owner)
                owner_id = mobile_id
                owner_type = "'MOBILE'"

        # Insert inventory
        if obj.id is None:
            statements.append(
                f"INSERT INTO {database}.{inventory_table} "
                f"(owner_id, owner_type, max_entries, max_volume, last_calculated_volume) "
                f"VALUES ({owner_id}, {owner_type}, {obj.max_entries}, "
                f"{obj.max_volume}, {obj.last_calculated_volume});"
            )
        else:
            statements.append(
                f"INSERT INTO {database}.{inventory_table} "
                f"(id, owner_id, owner_type, max_entries, max_volume, last_calculated_volume) "
                f"VALUES ({obj.id}, {owner_id}, {owner_type}, {obj.max_entries}, "
                f"{obj.max_volume}, {obj.last_calculated_volume});"
            )

        # Insert inventory entries (one-to-many)
        if obj.entries:
            for entry in obj.entries:
                is_max_stacked = 1 if entry.is_max_stacked else 0
                statements.append(
                    f"INSERT INTO {database}.{inventory_entries_table} "
                    f"(inventory_id, item_id, quantity, is_max_stacked) "
                    f"VALUES ({{inventory_id}}, {entry.item_id}, {entry.quantity}, {is_max_stacked});"
                )

        # Insert inventory owner (one-to-one)
        statements.append(
            f"INSERT INTO {database}.{inventory_owners_table} "
            f"(inventory_id, mobile_id, item_id, asset_id, player_id) "
            f"VALUES ({{inventory_id}}, {mobile_id}, {item_id}, {asset_id}, {player_id});"
        )

        return statements

    def create_inventory(
        self,
        database: str,
        obj: Inventory,
        table: Optional[str] = None,
    ) -> list[GameResult]:
        logger.info(
            f"=== CREATE_INVENTORY: database={database}, owner={obj.owner}, "
            f"max_entries={obj.max_entries}, max_volume={obj.max_volume}"
        )
        logger.debug(f"Inventory has {len(obj.entries)} entries")
        try:
            self.connect()
            cursor = self.connection.cursor()

            # Start transaction
            logger.debug("Starting transaction for inventory creation")
            cursor.execute("START TRANSACTION;")

            # Get SQL statements
            statements = self.get_inventory_sql(database, obj, table)
            logger.debug(
                f"Generated {len(statements)} SQL statements for inventory creation"
            )

            # Execute each statement and track last_insert_id
            last_id = None
            inventory_id_set = False
            for idx, stmt in enumerate(statements):
                # Replace placeholder with actual inventory_id
                if "{inventory_id}" in stmt:
                    current_inventory_id = obj.id if obj.id is not None else last_id
                    if current_inventory_id is None:
                        logger.error(
                            "Attempted to use inventory_id but no inventory insert occurred"
                        )
                        raise Exception(
                            "Attempted to use inventory_id but no inventory insert occurred"
                        )
                    stmt = stmt.replace("{inventory_id}", str(current_inventory_id))
                    logger.debug(
                        f"Replaced inventory_id placeholder with {current_inventory_id}"
                    )

                cursor.execute(stmt)

                # Get last insert id if this was an INSERT
                if stmt.strip().upper().startswith("INSERT"):
                    last_id = cursor.lastrowid
                    # If this was the inventory insert and obj.id was None, set it now
                    if (
                        not inventory_id_set
                        and obj.id is None
                        and "inventories" in stmt
                    ):
                        obj.id = last_id
                        inventory_id_set = True
                        logger.debug(
                            f"Set new inventory id={obj.id} from last_insert_id"
                        )

            # Commit transaction
            logger.debug("Committing transaction")
            self.connection.commit()
            cursor.close()

            logger.info(
                f"SUCCESS: Created inventory id={obj.id} with {len(obj.entries)} entries"
            )
            return [
                GameResult(
                    status=StatusType.SUCCESS,
                    message=f"Successfully created Inventory id={obj.id}",
                ),
            ]
        except Exception as e:
            logger.error(f"EXCEPTION in create_inventory: {type(e).__name__}: {str(e)}")
            if self.connection:
                logger.debug("Rolling back transaction")
                self.connection.rollback()
            return [
                GameResult(
                    status=StatusType.FAILURE,
                    message=f"Failed to save Inventory id={obj.id} to database={database}: {str(e)}",
                    error_code=GameError.DB_INSERT_FAILED,
                ),
            ]
        finally:
            if cursor:
                cursor.close()

    def update_inventory(
        self,
        database: str,
        obj: Inventory,
        table: Optional[str] = None,
    ) -> list[GameResult]:
        try:
            if obj.id is None:
                return [
                    GameResult(
                        status=StatusType.FAILURE,
                        message=f"Cannot update Inventory with id=None",
                        error_code=GameError.DB_INVALID_DATA,
                    ),
                ]

            self.connect()
            cursor = self.connection.cursor()

            # Start transaction
            cursor.execute("START TRANSACTION;")

            inventory_table = table if table else "inventories"
            inventory_entries_table = "inventory_entries"
            inventory_owners_table = "inventory_owners"

            # Extract owner information
            from game.ttypes import Owner

            mobile_id = "NULL"
            item_id = "NULL"
            asset_id = "NULL"
            player_id = "NULL"
            owner_type = "NULL"
            owner_id = "NULL"

            if obj.owner is not None:
                if isinstance(obj.owner, Owner):
                    if (
                        hasattr(obj.owner, "mobile_id")
                        and obj.owner.mobile_id is not None
                    ):
                        mobile_id = str(obj.owner.mobile_id)
                        owner_id = mobile_id
                        owner_type = "'MOBILE'"
                    elif (
                        hasattr(obj.owner, "item_id") and obj.owner.item_id is not None
                    ):
                        item_id = str(obj.owner.item_id)
                        owner_id = item_id
                        owner_type = "'ITEM'"
                    elif (
                        hasattr(obj.owner, "asset_id")
                        and obj.owner.asset_id is not None
                    ):
                        asset_id = str(obj.owner.asset_id)
                        owner_id = asset_id
                        owner_type = "'ASSET'"
                    elif (
                        hasattr(obj.owner, "player_id")
                        and obj.owner.player_id is not None
                    ):
                        player_id = str(obj.owner.player_id)
                        owner_id = player_id
                        owner_type = "'PLAYER'"
                elif isinstance(obj.owner, int):
                    mobile_id = str(obj.owner)
                    owner_id = mobile_id
                    owner_type = "'MOBILE'"

            # Update inventory
            cursor.execute(
                f"UPDATE {database}.{inventory_table} SET "
                f"owner_id = {owner_id}, "
                f"owner_type = {owner_type}, "
                f"max_entries = {obj.max_entries}, "
                f"max_volume = {obj.max_volume}, "
                f"last_calculated_volume = {obj.last_calculated_volume} "
                f"WHERE id = {obj.id};"
            )

            # Delete existing entries
            cursor.execute(
                f"DELETE FROM {database}.{inventory_entries_table} WHERE inventory_id = {obj.id};"
            )

            # Insert new entries
            if obj.entries:
                for entry in obj.entries:
                    is_max_stacked = 1 if entry.is_max_stacked else 0
                    cursor.execute(
                        f"INSERT INTO {database}.{inventory_entries_table} "
                        f"(inventory_id, item_id, quantity, is_max_stacked) "
                        f"VALUES ({obj.id}, {entry.item_id}, {entry.quantity}, {is_max_stacked});"
                    )

            # Update owner (delete and re-insert)
            cursor.execute(
                f"DELETE FROM {database}.{inventory_owners_table} WHERE inventory_id = {obj.id};"
            )

            cursor.execute(
                f"INSERT INTO {database}.{inventory_owners_table} "
                f"(inventory_id, mobile_id, item_id, asset_id, player_id) "
                f"VALUES ({obj.id}, {mobile_id}, {item_id}, {asset_id}, {player_id});"
            )

            # Commit transaction
            self.connection.commit()
            cursor.close()

            return [
                GameResult(
                    status=StatusType.SUCCESS,
                    message=f"Successfully updated Inventory id={obj.id}",
                ),
            ]
        except Exception as e:
            if self.connection:
                self.connection.rollback()
            return [
                GameResult(
                    status=StatusType.FAILURE,
                    message=f"Failed to update Inventory id={obj.id} in database={database}: {str(e)}",
                    error_code=GameError.DB_UPDATE_FAILED,
                ),
            ]
        finally:
            if cursor:
                cursor.close()

    def load_inventory(
        self,
        database: str,
        inventory_id: int,
        table: Optional[str] = None,
    ) -> Tuple[GameResult, Optional[Inventory]]:
        try:
            self.connect()
            cursor = self.connection.cursor(dictionary=True)

            inventory_table = table if table else "inventories"
            inventory_entries_table = "inventory_entries"
            inventory_owners_table = "inventory_owners"

            # Load the inventory
            cursor.execute(
                f"SELECT * FROM {database}.{inventory_table} WHERE id = %s;",
                (inventory_id,),
            )
            inv_row = cursor.fetchone()

            if not inv_row:
                cursor.close()
                return (
                    GameResult(
                        status=StatusType.FAILURE,
                        message=f"Inventory id={inventory_id} not found in database={database}",
                        error_code=GameError.DB_RECORD_NOT_FOUND,
                    ),
                    None,
                )

            # Load inventory entries
            cursor.execute(
                f"SELECT * FROM {database}.{inventory_entries_table} WHERE inventory_id = %s;",
                (inventory_id,),
            )
            entry_rows = cursor.fetchall()

            # Build entries list
            entries = []
            for row in entry_rows:
                entry = InventoryEntry(
                    item_id=row["item_id"],
                    quantity=row["quantity"],
                    is_max_stacked=row["is_max_stacked"],
                )
                entries.append(entry)

            # Load owner
            cursor.execute(
                f"SELECT * FROM {database}.{inventory_owners_table} WHERE inventory_id = %s;",
                (inventory_id,),
            )
            owner_row = cursor.fetchone()

            owner = None
            if owner_row:
                if owner_row["mobile_id"]:
                    owner = owner_row["mobile_id"]
                elif owner_row["item_id"]:
                    owner = owner_row["item_id"]
                elif owner_row["asset_id"]:
                    owner = owner_row["asset_id"]
                elif owner_row["player_id"]:
                    owner = owner_row["player_id"]

            # Create Inventory object
            inventory = Inventory(
                id=inv_row["id"],
                max_entries=inv_row["max_entries"],
                max_volume=inv_row["max_volume"],
                entries=entries,
                last_calculated_volume=inv_row["last_calculated_volume"],
                owner=owner,
            )

            cursor.close()

            return (
                GameResult(
                    status=StatusType.SUCCESS,
                    message=f"Successfully loaded Inventory id={inventory_id}",
                ),
                inventory,
            )
        except Exception as e:
            return (
                GameResult(
                    status=StatusType.FAILURE,
                    message=f"Failed to load Inventory id={inventory_id} from database={database}: {str(e)}",
                    error_code=GameError.DB_QUERY_FAILED,
                ),
                None,
            )
        finally:
            if cursor:
                cursor.close()

    def save_inventory(
        self,
        database: str,
        obj: Inventory,
        table: Optional[str] = None,
    ) -> list[GameResult]:
        if obj.id is None:
            return self.create_inventory(database, obj, table)
        else:
            return self.update_inventory(database, obj, table)

    def destroy_inventory(
        self,
        database: str,
        inventory_id: int,
        table: Optional[str] = None,
    ) -> list[GameResult]:
        try:
            self.connect()
            cursor = self.connection.cursor()

            # Start transaction
            cursor.execute("START TRANSACTION;")

            inventory_table = table if table else "inventories"
            inventory_entries_table = "inventory_entries"
            inventory_owners_table = "inventory_owners"

            # Delete inventory entries first (foreign key)
            cursor.execute(
                f"DELETE FROM {database}.{inventory_entries_table} WHERE inventory_id = {inventory_id};"
            )

            # Delete inventory owner
            cursor.execute(
                f"DELETE FROM {database}.{inventory_owners_table} WHERE inventory_id = {inventory_id};"
            )

            # Delete the inventory
            cursor.execute(
                f"DELETE FROM {database}.{inventory_table} WHERE id = {inventory_id};"
            )

            # Check if any rows were affected
            if cursor.rowcount == 0:
                self.connection.rollback()
                return [
                    GameResult(
                        status=StatusType.FAILURE,
                        message=f"Inventory id={inventory_id} not found in database={database}",
                        error_code=GameError.DB_RECORD_NOT_FOUND,
                    ),
                ]

            # Commit transaction
            self.connection.commit()
            cursor.close()

            return [
                GameResult(
                    status=StatusType.SUCCESS,
                    message=f"Successfully destroyed Inventory id={inventory_id}",
                ),
            ]
        except Exception as e:
            if self.connection:
                self.connection.rollback()
            return [
                GameResult(
                    status=StatusType.FAILURE,
                    message=f"Failed to destroy Inventory id={inventory_id} in database={database}: {str(e)}",
                    error_code=GameError.DB_DELETE_FAILED,
                ),
            ]
        finally:
            if cursor:
                cursor.close()

    def list_inventory(
        self,
        database: str,
        page: int,
        results_per_page: int,
        search_string: Optional[str] = None,
        table: Optional[str] = None,
    ) -> Tuple[GameResult, Optional[list[Inventory]], int]:
        """
        List inventories with pagination.

        Args:
            database: Database name
            page: Page number (0-indexed)
            results_per_page: Number of results per page
            search_string: Optional search string (ignored for Inventory - no searchable text fields)
            table: Optional table name override

        Returns:
            Tuple of (GameResult, list of Inventory objects, total count)
        """
        try:
            self.connect()
            cursor = self.connection.cursor(dictionary=True)

            inventory_table = table if table else "inventories"

            # Calculate offset
            offset = page * results_per_page

            # Note: search_string is ignored for inventories as there are no searchable text fields

            # Get total count
            count_query = f"SELECT COUNT(*) as total FROM {database}.{inventory_table};"
            cursor.execute(count_query)
            count_row = cursor.fetchone()
            total_count = count_row["total"] if count_row else 0

            # Get paginated results
            query = f"SELECT * FROM {database}.{inventory_table} ORDER BY id LIMIT %s OFFSET %s;"
            cursor.execute(query, (results_per_page, offset))
            inventory_rows = cursor.fetchall()

            # Convert rows to Inventory objects
            inventories = []
            for row in inventory_rows:
                # Load inventory entries
                inventory_entries_table = "inventory_entries"
                cursor.execute(
                    f"SELECT * FROM {database}.{inventory_entries_table} WHERE inventory_id = %s;",
                    (row["id"],),
                )
                entry_rows = cursor.fetchall()

                entries = []
                for entry_row in entry_rows:
                    entry = InventoryEntry(
                        item_id=entry_row["item_id"],
                        quantity=entry_row["quantity"],
                        is_max_stacked=entry_row["is_max_stacked"],
                    )
                    entries.append(entry)

                # Load owner information
                inventory_owners_table = "inventory_owners"
                cursor.execute(
                    f"SELECT * FROM {database}.{inventory_owners_table} WHERE inventory_id = %s;",
                    (row["id"],),
                )
                owner_row = cursor.fetchone()

                owner = None
                if owner_row:
                    from game.ttypes import Owner

                    owner = Owner()
                    if owner_row["mobile_id"]:
                        owner.mobile_id = owner_row["mobile_id"]
                    elif owner_row["item_id"]:
                        owner.item_id = owner_row["item_id"]
                    elif owner_row["asset_id"]:
                        owner.asset_id = owner_row["asset_id"]
                    elif owner_row["player_id"]:
                        owner.player_id = owner_row["player_id"]

                # Create Inventory object
                inventory = Inventory(
                    id=row["id"],
                    max_entries=row["max_entries"],
                    max_volume=row["max_volume"],
                    entries=entries,
                    last_calculated_volume=row["last_calculated_volume"],
                    owner=owner,
                )
                inventories.append(inventory)

            cursor.close()

            return (
                GameResult(
                    status=StatusType.SUCCESS,
                    message=f"Successfully listed {len(inventories)} inventories (total: {total_count})",
                ),
                inventories,
                total_count,
            )
        except Exception as e:
            return (
                GameResult(
                    status=StatusType.FAILURE,
                    message=f"Failed to list inventories from database={database}: {str(e)}",
                    error_code=GameError.DB_QUERY_FAILED,
                ),
                None,
                0,
            )
        finally:
            if cursor:
                cursor.close()
